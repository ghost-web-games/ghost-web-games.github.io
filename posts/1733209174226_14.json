{
  "title": "Three.js 최적화: 효율적인 3D 앱 만들기",
  "date": 1733209174521,
  "data": "{\n  \"time\": 1733540737466,\n  \"blocks\": [\n    {\n      \"id\": \"AdhYYEGtvk\",\n      \"type\": \"paragraph\",\n      \"data\": {\n        \"text\": \"Three.js로 3D 애플리케이션을 개발하다 보면 성능 저하를 겪는 경우가 많습니다. Javascript는 태생적으로 인터프리터언어이고 싱글 스레드 기반이기 때문입니다.이 장에서는 성능 문제를 진단하고 해결하기 위한 최적화 기법들을 소개합니다. 브라우저 환경에서의 GPU 자원 활용을 극대화하고, 렌더링 부하를 줄이는 다양한 방법을 다룹니다.\"\n      },\n      \"tunes\": {\n        \"textVariant\": \"\"\n      }\n    },\n    {\n      \"id\": \"urbY2nVDP0\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"1. 성능 병목 파악\",\n        \"level\": 4\n      }\n    },\n    {\n      \"id\": \"YdWRV5M_7M\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"(1) FPS 모니터링\",\n        \"level\": 5\n      }\n    },\n    {\n      \"id\": \"8cf-NAChYq\",\n      \"type\": \"list\",\n      \"data\": {\n        \"style\": \"unordered\",\n        \"meta\": {},\n        \"items\": [\n          {\n            \"content\": \"Stats.js 라이브러리를 사용하여 프레임 속도를 측정하고 렌더링 성능을 실시간으로 모니터링합니다.\",\n            \"meta\": {},\n            \"items\": []\n          }\n        ]\n      }\n    },\n    {\n      \"id\": \"zND0Oe2ntZ\",\n      \"type\": \"code\",\n      \"data\": {\n        \"code\": \"import Stats from 'stats.js';\\nconst stats = new Stats();\\ndocument.body.appendChild(stats.dom);\\n\\nfunction animate() {\\n  stats.begin();\\n  renderer.render(scene, camera);\\n  stats.end();\\n  requestAnimationFrame(animate);\\n}\\nanimate();\",\n        \"language\": \"javascript\",\n        \"showlinenumbers\": true\n      }\n    },\n    {\n      \"id\": \"Ovhj3vOTNR\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"(2) Chrome DevTools\",\n        \"level\": 5\n      }\n    },\n    {\n      \"id\": \"JcbDXPfnmt\",\n      \"type\": \"list\",\n      \"data\": {\n        \"style\": \"unordered\",\n        \"meta\": {},\n        \"items\": [\n          {\n            \"content\": \"DevTools의 Performance 탭을 활용하여 CPU/GPU 병목을 분석합니다. Record 버튼 클릭.애플리케이션을 실행하여 렌더링 과정을 기록.프레임별 성능 데이터를 분석.\",\n            \"meta\": {},\n            \"items\": []\n          }\n        ]\n      }\n    },\n    {\n      \"id\": \"4s59r4gRqn\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"2. 기초 최적화\",\n        \"level\": 4\n      }\n    },\n    {\n      \"id\": \"rsPv5XJsA8\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"(1) 메쉬와 재질의 재사용\",\n        \"level\": 5\n      }\n    },\n    {\n      \"id\": \"WvwbxQpu0c\",\n      \"type\": \"list\",\n      \"data\": {\n        \"style\": \"unordered\",\n        \"meta\": {},\n        \"items\": [\n          {\n            \"content\": \"동일한 Geometry와 Material을 여러 메쉬에서 재사용하여 메모리 사용량을 줄입니다\",\n            \"meta\": {},\n            \"items\": []\n          }\n        ]\n      }\n    },\n    {\n      \"id\": \"zba5pb6wBB\",\n      \"type\": \"code\",\n      \"data\": {\n        \"code\": \"const geometry = new THREE.BoxGeometry();\\nconst material = new THREE.MeshStandardMaterial({ color: 0x00ff00 });\\n\\nfor (let i = 0; i < 100; i++) {\\n  const mesh = new THREE.Mesh(geometry, material);\\n  mesh.position.set(Math.random() * 10, Math.random() * 10, Math.random() * 10);\\n  scene.add(mesh);\\n}\",\n        \"language\": \"javascript\",\n        \"showlinenumbers\": true\n      }\n    },\n    {\n      \"id\": \"MRIyAM814x\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"(2) 정점 수 줄이기\",\n        \"level\": 5\n      }\n    },\n    {\n      \"id\": \"DEsvvmx1to\",\n      \"type\": \"list\",\n      \"data\": {\n        \"style\": \"unordered\",\n        \"meta\": {},\n        \"items\": [\n          {\n            \"content\": \"복잡한 지오메트리를 사용하는 대신 <b>LOD (Level of Detail)</b>를 적용하여 멀리 있는 객체는 간단한 형태로 렌더링합니다.\",\n            \"meta\": {},\n            \"items\": []\n          }\n        ]\n      }\n    },\n    {\n      \"id\": \"ETtyFU4_Zu\",\n      \"type\": \"code\",\n      \"data\": {\n        \"code\": \"const lod = new THREE.LOD();\\nconst highDetail = new THREE.Mesh(new THREE.SphereGeometry(1, 32, 32));\\nconst lowDetail = new THREE.Mesh(new THREE.SphereGeometry(1, 8, 8));\\n\\nlod.addLevel(highDetail, 0);\\nlod.addLevel(lowDetail, 50);\\nscene.add(lod);\",\n        \"language\": \"javascript\",\n        \"showlinenumbers\": true\n      }\n    },\n    {\n      \"id\": \"3a1cL1tOBm\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"(3) 텍스처 최적화\",\n        \"level\": 5\n      }\n    },\n    {\n      \"id\": \"EBVjPWfgcb\",\n      \"type\": \"list\",\n      \"data\": {\n        \"style\": \"unordered\",\n        \"meta\": {},\n        \"items\": [\n          {\n            \"content\": \"텍스처 크기를 줄이고 압축 포맷(DDS, KTX2)을 사용하여 로드 시간을 단축합니다.\",\n            \"meta\": {},\n            \"items\": []\n          }\n        ]\n      }\n    },\n    {\n      \"id\": \"-Yd-zpjKRR\",\n      \"type\": \"code\",\n      \"data\": {\n        \"code\": \"const textureLoader = new THREE.TextureLoader();\\nconst texture = textureLoader.load('compressedTexture.ktx2');\",\n        \"language\": \"javascript\",\n        \"showlinenumbers\": true\n      }\n    },\n    {\n      \"id\": \"cVXcy7T2hr\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"(4) 그림자 품질 낮추기\",\n        \"level\": 5\n      }\n    },\n    {\n      \"id\": \"0yHpTH-XLc\",\n      \"type\": \"list\",\n      \"data\": {\n        \"style\": \"unordered\",\n        \"meta\": {},\n        \"items\": [\n          {\n            \"content\": \"그림자를 사용하는 경우 해상도를 줄이고 Soft Shadows를 비활성화합니다.\",\n            \"meta\": {},\n            \"items\": []\n          }\n        ]\n      }\n    },\n    {\n      \"id\": \"5qX9ChJMKg\",\n      \"type\": \"code\",\n      \"data\": {\n        \"code\": \"renderer.shadowMap.enabled = true;\\nrenderer.shadowMap.type = THREE.BasicShadowMap; // 낮은 품질의 그림자\",\n        \"language\": \"javascript\",\n        \"showlinenumbers\": true\n      }\n    },\n    {\n      \"id\": \"ZTo7Gd1N7N\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"3. 렌더링 최적화\",\n        \"level\": 4\n      }\n    },\n    {\n      \"id\": \"tteUV9pTBn\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"(1) Frustum Culling\",\n        \"level\": 5\n      }\n    },\n    {\n      \"id\": \"rKVGTM7i5z\",\n      \"type\": \"list\",\n      \"data\": {\n        \"style\": \"unordered\",\n        \"meta\": {},\n        \"items\": [\n          {\n            \"content\": \"카메라 시야 밖의 객체는 자동으로 렌더링하지 않도록 합니다.\",\n            \"meta\": {},\n            \"items\": []\n          }\n        ]\n      }\n    },\n    {\n      \"id\": \"pLxwzXL56y\",\n      \"type\": \"code\",\n      \"data\": {\n        \"code\": \"mesh.frustumCulled = true; // 기본값이 true\",\n        \"language\": \"javascript\",\n        \"showlinenumbers\": true\n      }\n    },\n    {\n      \"id\": \"zQbVMSwZlO\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"(2) Instanced Mesh\",\n        \"level\": 5\n      }\n    },\n    {\n      \"id\": \"oh3PLgYU3F\",\n      \"type\": \"list\",\n      \"data\": {\n        \"style\": \"unordered\",\n        \"meta\": {},\n        \"items\": [\n          {\n            \"content\": \"동일한 객체가 반복적으로 등장하는 경우, InstancedMesh를 사용하여 GPU 부하를 줄입니다.\",\n            \"meta\": {},\n            \"items\": []\n          }\n        ]\n      }\n    },\n    {\n      \"id\": \"VVWa88hEIx\",\n      \"type\": \"code\",\n      \"data\": {\n        \"code\": \"const geometry = new THREE.BoxGeometry(1, 1, 1);\\nconst material = new THREE.MeshStandardMaterial({ color: 0x00ff00 });\\nconst mesh = new THREE.InstancedMesh(geometry, material, 1000);\\n\\nfor (let i = 0; i < 1000; i++) {\\n  const matrix = new THREE.Matrix4();\\n  matrix.setPosition(Math.random() * 10, Math.random() * 10, Math.random() * 10);\\n  mesh.setMatrixAt(i, matrix);\\n}\\nscene.add(mesh);\",\n        \"language\": \"javascript\",\n        \"showlinenumbers\": true\n      }\n    },\n    {\n      \"id\": \"31pLtEVJMW\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"(3) Render Call 줄이기\",\n        \"level\": 5\n      }\n    },\n    {\n      \"id\": \"20rYzC363g\",\n      \"type\": \"list\",\n      \"data\": {\n        \"style\": \"unordered\",\n        \"meta\": {},\n        \"items\": [\n          {\n            \"content\": \"가능한 한 적은 draw call로 렌더링을 수행합니다. 여러 메쉬를 하나의 BufferGeometry로 병합합니다.\",\n            \"meta\": {},\n            \"items\": []\n          }\n        ]\n      }\n    },\n    {\n      \"id\": \"cRIITEM5bE\",\n      \"type\": \"code\",\n      \"data\": {\n        \"code\": \"const mergedGeometry = new THREE.BufferGeometry();\\nconst geometries = [geometry1, geometry2, geometry3];\\nmergedGeometry.mergeBufferGeometries(geometries);\\nconst mesh = new THREE.Mesh(mergedGeometry, material);\\nscene.add(mesh);\",\n        \"language\": \"javascript\",\n        \"showlinenumbers\": true\n      }\n    },\n    {\n      \"id\": \"q_VY1JObem\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"(4) Frame Rate 제어\",\n        \"level\": 5\n      }\n    },\n    {\n      \"id\": \"HiBcRl5iTz\",\n      \"type\": \"list\",\n      \"data\": {\n        \"style\": \"unordered\",\n        \"meta\": {},\n        \"items\": [\n          {\n            \"content\": \"고성능이 요구되지 않는 경우, requestAnimationFrame의 호출 빈도를 제한하여 CPU/GPU 자원을 절약합니다.\",\n            \"meta\": {},\n            \"items\": []\n          }\n        ]\n      }\n    },\n    {\n      \"id\": \"S_r8rOMemr\",\n      \"type\": \"code\",\n      \"data\": {\n        \"code\": \"let lastRender = 0;\\nconst fps = 30;\\nfunction animate(now) {\\n  if (now - lastRender > 1000 / fps) {\\n    renderer.render(scene, camera);\\n    lastRender = now;\\n  }\\n  requestAnimationFrame(animate);\\n}\\nanimate();\",\n        \"language\": \"javascript\",\n        \"showlinenumbers\": true\n      }\n    },\n    {\n      \"id\": \"vq1lXHYJQI\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"4. 네트워크 최적화\",\n        \"level\": 4\n      }\n    },\n    {\n      \"id\": \"AovD-FQDK8\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"(1) 리소스 미리 로드\",\n        \"level\": 5\n      }\n    },\n    {\n      \"id\": \"g39rzvtX_d\",\n      \"type\": \"list\",\n      \"data\": {\n        \"style\": \"unordered\",\n        \"meta\": {},\n        \"items\": [\n          {\n            \"content\": \"주요 리소스를 미리 로드하여 초기 로드 시간을 줄입니다.\",\n            \"meta\": {},\n            \"items\": []\n          }\n        ]\n      }\n    },\n    {\n      \"id\": \"Xnrf7Gxiub\",\n      \"type\": \"code\",\n      \"data\": {\n        \"code\": \"const textureLoader = new THREE.TextureLoader();\\nconst textures = [\\n  textureLoader.load('texture1.jpg'),\\n  textureLoader.load('texture2.jpg'),\\n];\",\n        \"language\": \"javascript\",\n        \"showlinenumbers\": true\n      }\n    },\n    {\n      \"id\": \"BaR2q33TGu\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"(2) Lazy Loading\",\n        \"level\": 5\n      }\n    },\n    {\n      \"id\": \"APCueEDV9j\",\n      \"type\": \"list\",\n      \"data\": {\n        \"style\": \"unordered\",\n        \"meta\": {},\n        \"items\": [\n          {\n            \"content\": \"사용되지 않는 리소스는 나중에 필요할 때 로드합니다.\",\n            \"meta\": {},\n            \"items\": []\n          }\n        ]\n      }\n    },\n    {\n      \"id\": \"72OFneTbyI\",\n      \"type\": \"code\",\n      \"data\": {\n        \"code\": \"let texture;\\ndocument.addEventListener('scroll', () => {\\n  if (!texture) {\\n    texture = textureLoader.load('largeTexture.jpg');\\n  }\\n});\",\n        \"language\": \"javascript\",\n        \"showlinenumbers\": true\n      }\n    },\n    {\n      \"id\": \"ZvYgByKs5s\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"(3) Web Workers\",\n        \"level\": 5\n      }\n    },\n    {\n      \"id\": \"eGBxYbEpCJ\",\n      \"type\": \"list\",\n      \"data\": {\n        \"style\": \"unordered\",\n        \"meta\": {},\n        \"items\": [\n          {\n            \"content\": \"복잡한 계산은 메인 스레드에서 분리하여 Web Workers로 처리합니다.\",\n            \"meta\": {},\n            \"items\": []\n          }\n        ]\n      }\n    },\n    {\n      \"id\": \"yNMW7jEOS-\",\n      \"type\": \"code\",\n      \"data\": {\n        \"code\": \"const worker = new Worker('path/to/worker.js');\\nworker.postMessage({ data: 'heavy computation' });\\nworker.onmessage = (event) => {\\n  console.log('Result:', event.data);\\n};\",\n        \"language\": \"javascript\",\n        \"showlinenumbers\": true\n      }\n    },\n    {\n      \"id\": \"m0fKMPKMoO\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"5. 코드 최적화\",\n        \"level\": 4\n      }\n    },\n    {\n      \"id\": \"KIiNDNVQut\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"(1) 애니메이션 최소화\",\n        \"level\": 5\n      }\n    },\n    {\n      \"id\": \"l9Ht4ovJiF\",\n      \"type\": \"list\",\n      \"data\": {\n        \"style\": \"unordered\",\n        \"meta\": {},\n        \"items\": [\n          {\n            \"content\": \"복잡한 애니메이션을 피하고, 필요한 애니메이션만 적용합니다.\",\n            \"meta\": {},\n            \"items\": []\n          }\n        ]\n      }\n    },\n    {\n      \"id\": \"aIh3Bc_FNQ\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"(2) 불필요한 객체 제거\",\n        \"level\": 5\n      }\n    },\n    {\n      \"id\": \"dS83mKYze-\",\n      \"type\": \"list\",\n      \"data\": {\n        \"style\": \"unordered\",\n        \"meta\": {},\n        \"items\": [\n          {\n            \"content\": \"사용하지 않는 메쉬와 텍스처를 즉시 제거하여 메모리 누수를 방지합니다.\",\n            \"meta\": {},\n            \"items\": []\n          }\n        ]\n      }\n    },\n    {\n      \"id\": \"4ne5nWKfK0\",\n      \"type\": \"code\",\n      \"data\": {\n        \"code\": \"scene.remove(mesh);\\nmesh.geometry.dispose();\\nmesh.material.dispose();\",\n        \"language\": \"javascript\",\n        \"showlinenumbers\": true\n      }\n    },\n    {\n      \"id\": \"dsMjUpW1hn\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"(3) Shader 최적화\",\n        \"level\": 5\n      }\n    },\n    {\n      \"id\": \"mt4IOvuYYI\",\n      \"type\": \"list\",\n      \"data\": {\n        \"style\": \"unordered\",\n        \"meta\": {},\n        \"items\": [\n          {\n            \"content\": \"ShaderMaterial을 사용할 때 불필요한 연산을 줄입니다.\",\n            \"meta\": {},\n            \"items\": []\n          }\n        ]\n      }\n    },\n    {\n      \"id\": \"JXGWxUZkxq\",\n      \"type\": \"code\",\n      \"data\": {\n        \"code\": \"void main() {\\n  vec4 color = vec4(1.0, 0.0, 0.0, 1.0); // 계산 최소화\\n  gl_FragColor = color;\\n}\",\n        \"language\": \"plain\",\n        \"showlinenumbers\": true\n      }\n    },\n    {\n      \"id\": \"Ol-IxOMhxd\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"정리\",\n        \"level\": 3\n      }\n    },\n    {\n      \"id\": \"m120njg2mq\",\n      \"type\": \"paragraph\",\n      \"data\": {\n        \"text\": \"Three.js 최적화는 복잡한 애플리케이션에서도 부드러운 사용자 경험을 보장하기 위한 필수 작업입니다. 이 장에서 다룬 기법들을 통해 애플리케이션의 성능을 개선하고, 하드웨어 리소스를 효율적으로 활용하는 방법을 배웠습니다.&nbsp;\"\n      },\n      \"tunes\": {\n        \"textVariant\": \"\"\n      }\n    }\n  ],\n  \"version\": \"2.30.7\"\n}",
  "id": "1733209174226_14"
}