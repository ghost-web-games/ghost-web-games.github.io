{
  "title": "4. Three.js의 활용 확장",
  "date": 1733128536708,
  "data": "{\n  \"time\": 1733218144746,\n  \"blocks\": [\n    {\n      \"id\": \"tuHUnhejbo\",\n      \"type\": \"paragraph\",\n      \"data\": {\n        \"text\": \"이 장에서는 Three.js의 중급 기능을 활용하여 더 풍부하고 복잡한 3D 장면을 만드는 방법을 다룹니다. 이 과정에서는 텍스처, 고급 재질, 애니메이션, 상호작용 등 실무적인 기법들을 배울 수 있습니다.\"\n      },\n      \"tunes\": {\n        \"textVariant\": \"\"\n      }\n    },\n    {\n      \"id\": \"l3iPJFL2r_\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"1. 텍스처와 맵핑\",\n        \"level\": 4\n      }\n    },\n    {\n      \"id\": \"LXtYwisjgh\",\n      \"type\": \"paragraph\",\n      \"data\": {\n        \"text\": \"텍스처는 객체의 표면에 이미지를 입히는 데 사용됩니다. Three.js는 다양한 맵핑 기술을 제공하여 더욱 사실적인 효과를 구현할 수 있습니다.\"\n      },\n      \"tunes\": {\n        \"textVariant\": \"\"\n      }\n    },\n    {\n      \"id\": \"MMkfeMGI7e\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"(1) 기본 텍스처 적용하기\",\n        \"level\": 5\n      }\n    },\n    {\n      \"id\": \"CKQvPTroHZ\",\n      \"type\": \"paragraph\",\n      \"data\": {\n        \"text\": \"<b>TextureLoader</b>를 사용하여 이미지를 로드한 뒤 Material에 추가합니다.\"\n      },\n      \"tunes\": {\n        \"textVariant\": \"\"\n      }\n    },\n    {\n      \"id\": \"wlh1MzLByC\",\n      \"type\": \"code\",\n      \"data\": {\n        \"code\": \"const textureLoader = new THREE.TextureLoader();\\nconst texture = textureLoader.load('path/to/texture.jpg');\\n\\nconst material = new THREE.MeshBasicMaterial({ map: texture });\\nconst geometry = new THREE.BoxGeometry();\\nconst cube = new THREE.Mesh(geometry, material);\\nscene.add(cube);\",\n        \"language\": \"javascript\",\n        \"showlinenumbers\": true\n      }\n    },\n    {\n      \"id\": \"xZRZtFgZhk\",\n      \"type\": \"embed\",\n      \"data\": {\n        \"service\": \"codepen\",\n        \"source\": \"https://codepen.io/ghostwebservice/pen/bNbVEoa\",\n        \"embed\": \"https://codepen.io/ghostwebservice/embed/bNbVEoa?height=300&theme-id=0&default-tab=css,result&embed-version=2\",\n        \"width\": 600,\n        \"height\": 300,\n        \"caption\": \"박스 텍스쳐\"\n      }\n    },\n    {\n      \"id\": \"KPQTSOWpt9\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"(2) 반복 및 래핑 설정\",\n        \"level\": 5\n      }\n    },\n    {\n      \"id\": \"rrjZuVrx95\",\n      \"type\": \"paragraph\",\n      \"data\": {\n        \"text\": \"텍스처가 객체 표면에 반복되거나 잘리지 않도록 조정할 수 있습니다.\"\n      },\n      \"tunes\": {\n        \"textVariant\": \"\"\n      }\n    },\n    {\n      \"id\": \"6jXaEp_Mkk\",\n      \"type\": \"code\",\n      \"data\": {\n        \"code\": \"texture.wrapS = THREE.RepeatWrapping;\\ntexture.wrapT = THREE.RepeatWrapping;\\ntexture.repeat.set(2, 2); // x축과 y축 반복 설정\",\n        \"language\": \"javascript\",\n        \"showlinenumbers\": true\n      }\n    },\n    {\n      \"id\": \"c4Dyo-FFcO\",\n      \"type\": \"embed\",\n      \"data\": {\n        \"service\": \"codepen\",\n        \"source\": \"https://codepen.io/ghostwebservice/pen/GgKpoOm\",\n        \"embed\": \"https://codepen.io/ghostwebservice/embed/GgKpoOm?height=300&theme-id=0&default-tab=css,result&embed-version=2\",\n        \"width\": 600,\n        \"height\": 300,\n        \"caption\": \"반복 텍스쳐\"\n      }\n    },\n    {\n      \"id\": \"PsgXobQWVA\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"(3) 고급 맵핑 기법\",\n        \"level\": 5\n      }\n    },\n    {\n      \"id\": \"JesTv88ohh\",\n      \"type\": \"list\",\n      \"data\": {\n        \"style\": \"unordered\",\n        \"meta\": {},\n        \"items\": [\n          {\n            \"content\": \"Normal Map: 표면의 미세한 굴곡 표현.\",\n            \"meta\": {},\n            \"items\": []\n          },\n          {\n            \"content\": \"Bump Map: 표면 높낮이 표현.\",\n            \"meta\": {},\n            \"items\": []\n          },\n          {\n            \"content\": \"Specular Map: 반사광 설정.\",\n            \"meta\": {},\n            \"items\": []\n          }\n        ]\n      }\n    },\n    {\n      \"id\": \"2AB4UHVM38\",\n      \"type\": \"code\",\n      \"data\": {\n        \"code\": \"const normalTexture = textureLoader.load('path/to/normal.jpg');\\nconst material = new THREE.MeshStandardMaterial({\\n  map: texture,\\n  normalMap: normalTexture,\\n});\",\n        \"language\": \"javascript\",\n        \"showlinenumbers\": true\n      }\n    },\n    {\n      \"id\": \"xmkTZQtZlP\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"2. 애니메이션 추가\",\n        \"level\": 4\n      }\n    },\n    {\n      \"id\": \"-8i4RHtKgH\",\n      \"type\": \"paragraph\",\n      \"data\": {\n        \"text\": \"Three.js는 JavaScript의 requestAnimationFrame을 활용하여 객체를 움직이거나 상태를 변경하는 애니메이션을 구현합니다.\"\n      },\n      \"tunes\": {\n        \"textVariant\": \"\"\n      }\n    },\n    {\n      \"id\": \"Uo-lT8jSco\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"(1) 수동 애니메이션\",\n        \"level\": 5\n      }\n    },\n    {\n      \"id\": \"NPwZfam2ze\",\n      \"type\": \"paragraph\",\n      \"data\": {\n        \"text\": \"객체의 속성을 직접 변경하여 움직임을 만듭니다.\"\n      },\n      \"tunes\": {\n        \"textVariant\": \"\"\n      }\n    },\n    {\n      \"id\": \"iT88JKEJJF\",\n      \"type\": \"code\",\n      \"data\": {\n        \"code\": \"function animate() {\\n  cube.rotation.x += 0.01;\\n  cube.rotation.y += 0.01;\\n  renderer.render(scene, camera);\\n  requestAnimationFrame(animate);\\n}\\nanimate();\",\n        \"language\": \"javascript\",\n        \"showlinenumbers\": true\n      }\n    },\n    {\n      \"id\": \"DiB6dZWNhD\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"(2) GSAP을 사용한 애니메이션\",\n        \"level\": 5\n      }\n    },\n    {\n      \"id\": \"7HjSxI7bTi\",\n      \"type\": \"paragraph\",\n      \"data\": {\n        \"text\": \"<a><span>GSAP</span></a>은 Three.js와 함께 자주 사용되는 애니메이션 라이브러리입니다.\"\n      },\n      \"tunes\": {\n        \"textVariant\": \"\"\n      }\n    },\n    {\n      \"id\": \"uNLVJa9lIO\",\n      \"type\": \"code\",\n      \"data\": {\n        \"code\": \"import gsap from 'gsap';\\n\\ngsap.to(cube.position, { x: 2, duration: 1, ease: 'power1.inOut' });\\ngsap.to(cube.rotation, { y: Math.PI * 2, duration: 2 });\",\n        \"language\": \"javascript\",\n        \"showlinenumbers\": true\n      }\n    },\n    {\n      \"id\": \"d8XFWQTbfw\",\n      \"type\": \"embed\",\n      \"data\": {\n        \"service\": \"codepen\",\n        \"source\": \"https://codepen.io/ghostwebservice/pen/xbKwZWb\",\n        \"embed\": \"https://codepen.io/ghostwebservice/embed/xbKwZWb?height=300&theme-id=0&default-tab=css,result&embed-version=2\",\n        \"width\": 600,\n        \"height\": 300,\n        \"caption\": \"GSAP 애니메이션\"\n      }\n    },\n    {\n      \"id\": \"TsKWpqlZhw\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"(3) 키프레임 애니메이션\",\n        \"level\": 5\n      }\n    },\n    {\n      \"id\": \"n8BNg_y7XG\",\n      \"type\": \"paragraph\",\n      \"data\": {\n        \"text\": \"Three.js의 KeyframeTrack과 AnimationMixer를 사용하면 더 정교한 애니메이션을 구현할 수 있습니다.\"\n      },\n      \"tunes\": {\n        \"textVariant\": \"\"\n      }\n    },\n    {\n      \"id\": \"Lzc28vQnYO\",\n      \"type\": \"code\",\n      \"data\": {\n        \"code\": \"const positionKF = new THREE.VectorKeyframeTrack(\\n  '.position', // 대상 속성\\n  [0, 1, 2],   // 시간 (초 단위)\\n  [0, 0, 0, 2, 2, 2, 0, 0, 0] // 위치 값\\n);\\n\\nconst clip = new THREE.AnimationClip('move', -1, [positionKF]);\\nconst mixer = new THREE.AnimationMixer(cube);\\nconst action = mixer.clipAction(clip);\\naction.play();\\n\\nfunction animate(delta) {\\n  mixer.update(delta);\\n  renderer.render(scene, camera);\\n  requestAnimationFrame(animate);\\n}\",\n        \"language\": \"javascript\",\n        \"showlinenumbers\": true\n      }\n    },\n    {\n      \"id\": \"z6FKaT99eu\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"3. 사용자 상호작용\",\n        \"level\": 4\n      }\n    },\n    {\n      \"id\": \"Dt-CIXd35M\",\n      \"type\": \"paragraph\",\n      \"data\": {\n        \"text\": \"Three.js에서는 사용자 입력(마우스, 키보드 등)을 처리하여 3D 장면과 상호작용할 수 있습니다.\"\n      },\n      \"tunes\": {\n        \"textVariant\": \"\"\n      }\n    },\n    {\n      \"id\": \"wMf1YJfh4P\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"(1) Raycaster로 클릭 이벤트 구현\",\n        \"level\": 5\n      }\n    },\n    {\n      \"id\": \"6mUNxdbZvA\",\n      \"type\": \"paragraph\",\n      \"data\": {\n        \"text\": \"Raycaster는 화면상의 마우스 클릭을 3D 공간으로 변환하여 객체와의 교차 여부를 계산합니다.\"\n      },\n      \"tunes\": {\n        \"textVariant\": \"\"\n      }\n    },\n    {\n      \"id\": \"Ak7rh5rvkd\",\n      \"type\": \"code\",\n      \"data\": {\n        \"code\": \"const raycaster = new THREE.Raycaster();\\nconst mouse = new THREE.Vector2();\\n\\nwindow.addEventListener('click', (event) => {\\n  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\\n  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;\\n\\n  raycaster.setFromCamera(mouse, camera);\\n  const intersects = raycaster.intersectObjects(scene.children);\\n\\n  if (intersects.length > 0) {\\n    console.log('Clicked on:', intersects[0].object);\\n  }\\n});\",\n        \"language\": \"javascript\",\n        \"showlinenumbers\": true\n      }\n    },\n    {\n      \"id\": \"RwTqzALl_0\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"(2) OrbitControls를 사용한 뷰 조작\",\n        \"level\": 5\n      }\n    },\n    {\n      \"id\": \"u1VaVzbkN9\",\n      \"type\": \"paragraph\",\n      \"data\": {\n        \"text\": \"Three.js의 OrbitControls는 카메라의 시점을 마우스 드래그로 조작할 수 있게 합니다.\"\n      },\n      \"tunes\": {\n        \"textVariant\": \"\"\n      }\n    },\n    {\n      \"id\": \"6ixigbqfwN\",\n      \"type\": \"code\",\n      \"data\": {\n        \"code\": \"import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';\\nconst controls = new OrbitControls(camera, renderer.domElement);\\ncontrols.enableDamping = true; // 부드러운 움직임\",\n        \"language\": \"javascript\",\n        \"showlinenumbers\": true\n      }\n    },\n    {\n      \"id\": \"wZqh-WhBrP\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"4. 입자 시스템과 파티클 효과\",\n        \"level\": 4\n      }\n    },\n    {\n      \"id\": \"LwE5AQFNrX\",\n      \"type\": \"paragraph\",\n      \"data\": {\n        \"text\": \"입자 시스템은 연기, 불꽃, 빛나는 효과를 표현하는 데 유용합니다.\"\n      },\n      \"tunes\": {\n        \"textVariant\": \"\"\n      }\n    },\n    {\n      \"id\": \"ARk2gKajRp\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"(1) 간단한 파티클 생성\",\n        \"level\": 5\n      }\n    },\n    {\n      \"id\": \"-XAxy8NvHX\",\n      \"type\": \"paragraph\",\n      \"data\": {\n        \"text\": \"입자는 보통 Points 객체를 사용하여 구현됩니다.\"\n      },\n      \"tunes\": {\n        \"textVariant\": \"\"\n      }\n    },\n    {\n      \"id\": \"zI_fy0Mzul\",\n      \"type\": \"code\",\n      \"data\": {\n        \"code\": \"const particleGeometry = new THREE.BufferGeometry();\\nconst particleCount = 500;\\nconst positions = new Float32Array(particleCount * 3);\\n\\nfor (let i = 0; i < particleCount; i++) {\\n  positions[i * 3] = Math.random() * 10 - 5; // x\\n  positions[i * 3 + 1] = Math.random() * 10 - 5; // y\\n  positions[i * 3 + 2] = Math.random() * 10 - 5; // z\\n}\\n\\nparticleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));\\nconst particleMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.1 });\\nconst particles = new THREE.Points(particleGeometry, particleMaterial);\\nscene.add(particles);\",\n        \"language\": \"javascript\",\n        \"showlinenumbers\": true\n      }\n    },\n    {\n      \"id\": \"S-lto5GmlV\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"(2) Shader를 이용한 커스텀 파티클\",\n        \"level\": 5\n      }\n    },\n    {\n      \"id\": \"77ga2mgjre\",\n      \"type\": \"paragraph\",\n      \"data\": {\n        \"text\": \"Three.js의 ShaderMaterial을 활용하여 입자 효과를 더욱 커스터마이징할 수 있습니다.\"\n      },\n      \"tunes\": {\n        \"textVariant\": \"\"\n      }\n    },\n    {\n      \"id\": \"iFKGGjezIt\",\n      \"type\": \"code\",\n      \"data\": {\n        \"code\": \"const particleShaderMaterial = new THREE.ShaderMaterial({\\n  vertexShader: `\\n    void main() {\\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\\n      gl_PointSize = 5.0;\\n    }\\n  `,\\n  fragmentShader: `\\n    void main() {\\n      gl_FragColor = vec4(1.0, 0.5, 0.0, 1.0);\\n    }\\n  `\\n});\\nconst customParticles = new THREE.Points(particleGeometry, particleShaderMaterial);\\nscene.add(customParticles);\",\n        \"language\": \"javascript\",\n        \"showlinenumbers\": true\n      }\n    },\n    {\n      \"id\": \"150HC0uSyL\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"5. 후처리 효과(Post-processing)\",\n        \"level\": 4\n      }\n    },\n    {\n      \"id\": \"RXVPFr_DAD\",\n      \"type\": \"paragraph\",\n      \"data\": {\n        \"text\": \"Three.js는 장면을 렌더링한 후 추가 효과를 적용할 수 있는 후처리 시스템을 지원합니다.\"\n      },\n      \"tunes\": {\n        \"textVariant\": \"\"\n      }\n    },\n    {\n      \"id\": \"xWMxbYldpd\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"(1) Bloom 효과\",\n        \"level\": 5\n      }\n    },\n    {\n      \"id\": \"BNVALMPOHS\",\n      \"type\": \"paragraph\",\n      \"data\": {\n        \"text\": \"UnrealBloomPass를 사용하여 빛이 번지는 효과를 추가합니다.\"\n      },\n      \"tunes\": {\n        \"textVariant\": \"\"\n      }\n    },\n    {\n      \"id\": \"In23GUT6-t\",\n      \"type\": \"code\",\n      \"data\": {\n        \"code\": \"import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';\\nimport { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';\\nimport { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';\\n\\nconst composer = new EffectComposer(renderer);\\ncomposer.addPass(new RenderPass(scene, camera));\\ncomposer.addPass(new UnrealBloomPass({ strength: 1.5, radius: 0.4, threshold: 0.85 }));\\n\\nfunction animate() {\\n  composer.render();\\n  requestAnimationFrame(animate);\\n}\\nanimate();\",\n        \"language\": \"javascript\",\n        \"showlinenumbers\": true\n      }\n    },\n    {\n      \"id\": \"Pg1Wr4O6mw\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"정리\",\n        \"level\": 3\n      }\n    },\n    {\n      \"id\": \"C_XG5SMbRn\",\n      \"type\": \"paragraph\",\n      \"data\": {\n        \"text\": \"이번 장에서는 Three.js를 활용한 중급 기술들을 살펴보았습니다. 텍스처와 재질을 이용해 사실적인 객체를 만들고, 애니메이션과 상호작용으로 동적인 장면을 구성하며, 입자 시스템과 후처리로 시각적 효과를 추가했습니다. 다음 장에서는 고급 기술과 성능 최적화에 대해 다루겠습니다.\"\n      },\n      \"tunes\": {\n        \"textVariant\": \"\"\n      }\n    }\n  ],\n  \"version\": \"2.30.7\"\n}",
  "id": "1733128536667_10"
}