{
  "title": "5. Three.js의 한계 넘기기",
  "date": 1733134153907,
  "data": "{\n  \"time\": 1733134153906,\n  \"blocks\": [\n    {\n      \"id\": \"o5Zz0eXXZv\",\n      \"type\": \"paragraph\",\n      \"data\": {\n        \"text\": \"이 장에서는 Three.js의 고급 주제를 다룹니다. 성능 최적화, 커스텀 셰이더 작성, WebGL 확장 기능 활용, 그리고 실제 프로젝트에서 사용할 수 있는 팁과 트릭을 소개합니다.\"\n      },\n      \"tunes\": {\n        \"textVariant\": \"\"\n      }\n    },\n    {\n      \"id\": \"K49a_dfHaS\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"1. 성능 최적화\",\n        \"level\": 4\n      }\n    },\n    {\n      \"id\": \"sOfyelVL4S\",\n      \"type\": \"paragraph\",\n      \"data\": {\n        \"text\": \"Three.js를 사용하면서 고성능 3D 애플리케이션을 구축하려면 최적화가 필수입니다. 다음은 성능 향상을 위한 주요 기법들입니다.\"\n      },\n      \"tunes\": {\n        \"textVariant\": \"\"\n      }\n    },\n    {\n      \"id\": \"1gbJuSR6IX\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"(1) 최소한의 리소스 사용\",\n        \"level\": 5\n      }\n    },\n    {\n      \"id\": \"118nfRA9x3\",\n      \"type\": \"list\",\n      \"data\": {\n        \"style\": \"unordered\",\n        \"meta\": {},\n        \"items\": [\n          {\n            \"content\": \"Geometry 합치기: 동일한 메쉬를 여러 개 사용하는 대신, BufferGeometryUtils.mergeBufferGeometries를 활용해 하나의 Geometry로 합칩니다.\",\n            \"meta\": {},\n            \"items\": []\n          }\n        ]\n      }\n    },\n    {\n      \"id\": \"XbJZ1e1bex\",\n      \"type\": \"code\",\n      \"data\": {\n        \"code\": \"import { mergeBufferGeometries } from 'three/examples/jsm/utils/BufferGeometryUtils.js';\\n\\nconst geometry1 = new THREE.BoxGeometry();\\nconst geometry2 = new THREE.SphereGeometry();\\nconst mergedGeometry = mergeBufferGeometries([geometry1, geometry2]);\\nconst material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });\\nconst mesh = new THREE.Mesh(mergedGeometry, material);\\nscene.add(mesh);\",\n        \"language\": \"javascript\",\n        \"showlinenumbers\": true\n      }\n    },\n    {\n      \"id\": \"Z1u8doXstU\",\n      \"type\": \"list\",\n      \"data\": {\n        \"style\": \"unordered\",\n        \"meta\": {},\n        \"items\": [\n          {\n            \"content\": \"InstancedMesh 사용: 동일한 객체가 반복될 때 GPU에 한 번만 데이터를 전송하여 렌더링 성능을 향상시킵니다.\",\n            \"meta\": {},\n            \"items\": []\n          }\n        ]\n      }\n    },\n    {\n      \"id\": \"WcCfrch3b4\",\n      \"type\": \"code\",\n      \"data\": {\n        \"code\": \"const geometry = new THREE.BoxGeometry();\\nconst material = new THREE.MeshBasicMaterial();\\nconst count = 1000;\\nconst instancedMesh = new THREE.InstancedMesh(geometry, material, count);\\n\\nfor (let i = 0; i < count; i++) {\\n  const matrix = new THREE.Matrix4();\\n  matrix.setPosition(Math.random() * 10, Math.random() * 10, Math.random() * 10);\\n  instancedMesh.setMatrixAt(i, matrix);\\n}\\nscene.add(instancedMesh);\",\n        \"language\": \"javascript\",\n        \"showlinenumbers\": true\n      }\n    },\n    {\n      \"id\": \"k6pAn-5k1M\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"(2) Level of Detail (LOD) 사용\",\n        \"level\": 5\n      }\n    },\n    {\n      \"id\": \"9PO_Ofp5eV\",\n      \"type\": \"paragraph\",\n      \"data\": {\n        \"text\": \"LOD를 통해 멀리 있는 객체는 저해상도로, 가까이 있는 객체는 고해상도로 렌더링합니다.\"\n      },\n      \"tunes\": {\n        \"textVariant\": \"\"\n      }\n    },\n    {\n      \"id\": \"99OGJHF24C\",\n      \"type\": \"code\",\n      \"data\": {\n        \"code\": \"const lod = new THREE.LOD();\\nconst highRes = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), new THREE.MeshBasicMaterial({ color: 0xff0000 }));\\nconst lowRes = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), new THREE.MeshBasicMaterial({ color: 0x00ff00 }));\\n\\nlod.addLevel(highRes, 0);\\nlod.addLevel(lowRes, 50);\\nscene.add(lod);\",\n        \"language\": \"javascript\",\n        \"showlinenumbers\": true\n      }\n    },\n    {\n      \"id\": \"it4zGzAZXq\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"(3) 텍스처 최적화\",\n        \"level\": 5\n      }\n    },\n    {\n      \"id\": \"UnFe-mYjtc\",\n      \"type\": \"list\",\n      \"data\": {\n        \"style\": \"unordered\",\n        \"meta\": {},\n        \"items\": [\n          {\n            \"content\": \"텍스처 크기를 적절히 줄이고, PNG 대신 JPEG 같은 압축된 형식을 사용합니다.\",\n            \"meta\": {},\n            \"items\": []\n          },\n          {\n            \"content\": \"THREE.CompressedTexture를 활용해 GPU 메모리를 절약합니다.\",\n            \"meta\": {},\n            \"items\": []\n          }\n        ]\n      }\n    },\n    {\n      \"id\": \"GsusRIwbck\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"(4) 프레임워크 내장 옵션 활용\",\n        \"level\": 5\n      }\n    },\n    {\n      \"id\": \"6ua6iWldAt\",\n      \"type\": \"list\",\n      \"data\": {\n        \"style\": \"unordered\",\n        \"meta\": {},\n        \"items\": [\n          {\n            \"content\": \"Frustum Culling: 카메라 뷰에 포함되지 않은 객체는 자동으로 렌더링하지 않습니다.\",\n            \"meta\": {},\n            \"items\": []\n          },\n          {\n            \"content\": \"Dynamic Resolution Scaling: 장치 성능에 따라 해상도를 동적으로 변경합니다.\",\n            \"meta\": {},\n            \"items\": []\n          }\n        ]\n      }\n    },\n    {\n      \"id\": \"dgiNxkG2_M\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"2. 커스텀 셰이더 작성\",\n        \"level\": 4\n      }\n    },\n    {\n      \"id\": \"REA75qXGUV\",\n      \"type\": \"paragraph\",\n      \"data\": {\n        \"text\": \"셰이더는 GPU에서 실행되는 프로그램으로, Three.js의 기능을 확장하거나 최적화할 때 필수적입니다.\"\n      },\n      \"tunes\": {\n        \"textVariant\": \"\"\n      }\n    },\n    {\n      \"id\": \"kqBz5g44pj\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"(1) 셰이더 기본 구조\",\n        \"level\": 5\n      }\n    },\n    {\n      \"id\": \"BQuLtSlaQU\",\n      \"type\": \"paragraph\",\n      \"data\": {\n        \"text\": \"Three.js의 ShaderMaterial을 사용하여 GLSL 코드를 작성합니다.\"\n      },\n      \"tunes\": {\n        \"textVariant\": \"\"\n      }\n    },\n    {\n      \"id\": \"91RUMYW7R2\",\n      \"type\": \"code\",\n      \"data\": {\n        \"code\": \"const material = new THREE.ShaderMaterial({\\n  vertexShader: `\\n    void main() {\\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\\n    }\\n  `,\\n  fragmentShader: `\\n    void main() {\\n      gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); // 빨간색\\n    }\\n  `\\n});\\nconst geometry = new THREE.PlaneGeometry();\\nconst mesh = new THREE.Mesh(geometry, material);\\nscene.add(mesh);\",\n        \"language\": \"javascript\",\n        \"showlinenumbers\": true\n      }\n    },\n    {\n      \"id\": \"1WhH075AV1\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"(2) Uniforms를 이용한 데이터 전달\",\n        \"level\": 5\n      }\n    },\n    {\n      \"id\": \"nEWvFa3VJg\",\n      \"type\": \"paragraph\",\n      \"data\": {\n        \"text\": \"JavaScript에서 셰이더로 데이터를 전달하려면 uniforms를 사용합니다.\"\n      },\n      \"tunes\": {\n        \"textVariant\": \"\"\n      }\n    },\n    {\n      \"id\": \"2kR1L0D5iy\",\n      \"type\": \"code\",\n      \"data\": {\n        \"code\": \"const material = new THREE.ShaderMaterial({\\n  uniforms: {\\n    uTime: { value: 0.0 }\\n  },\\n  vertexShader: `\\n    uniform float uTime;\\n    void main() {\\n      vec3 transformed = position + sin(uTime) * 0.1;\\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(transformed, 1.0);\\n    }\\n  `,\\n  fragmentShader: `\\n    void main() {\\n      gl_FragColor = vec4(0.0, 0.5, 1.0, 1.0);\\n    }\\n  `\\n});\\n\\nfunction animate(time) {\\n  material.uniforms.uTime.value = time / 1000.0;\\n  requestAnimationFrame(animate);\\n}\\nanimate(0);\",\n        \"language\": \"javascript\",\n        \"showlinenumbers\": true\n      }\n    },\n    {\n      \"id\": \"ehUg-9U2JT\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"(3) ShaderLib 확장\",\n        \"level\": 5\n      }\n    },\n    {\n      \"id\": \"lSCky79fh1\",\n      \"type\": \"paragraph\",\n      \"data\": {\n        \"text\": \"Three.js의 기본 셰이더 라이브러리를 수정하거나 확장하여 효율적으로 셰이더를 재사용할 수 있습니다.\"\n      },\n      \"tunes\": {\n        \"textVariant\": \"\"\n      }\n    },\n    {\n      \"id\": \"R6UVVeUZLH\",\n      \"type\": \"code\",\n      \"data\": {\n        \"code\": \"import { ShaderLib } from 'three';\\nShaderLib.phong.fragmentShader = ShaderLib.phong.fragmentShader.replace(\\n  '#include <dithering_fragment>',\\n  `\\n  #include <dithering_fragment>\\n  gl_FragColor.rgb += vec3(0.2, 0.0, 0.0); // 빨간색 추가\\n  `\\n);\",\n        \"language\": \"javascript\",\n        \"showlinenumbers\": true\n      }\n    },\n    {\n      \"id\": \"6yRPb3SpDd\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"3. WebGL 확장 활용\",\n        \"level\": 4\n      }\n    },\n    {\n      \"id\": \"LInXghOQ4K\",\n      \"type\": \"paragraph\",\n      \"data\": {\n        \"text\": \"Three.js는 WebGL의 추상화된 레이어 위에 구축되었습니다. 따라서 WebGL의 강력한 확장 기능을 활용하면 성능과 표현력을 더욱 높일 수 있습니다.\"\n      },\n      \"tunes\": {\n        \"textVariant\": \"\"\n      }\n    },\n    {\n      \"id\": \"fyLscuZAY0\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"(1) Multiple Render Targets (MRT)\",\n        \"level\": 5\n      }\n    },\n    {\n      \"id\": \"tTOYTlEHax\",\n      \"type\": \"paragraph\",\n      \"data\": {\n        \"text\": \"여러 렌더 타겟을 활용하여 그림자 맵이나 포스트 프로세싱을 최적화합니다.\"\n      },\n      \"tunes\": {\n        \"textVariant\": \"\"\n      }\n    },\n    {\n      \"id\": \"-CfGVB3JGn\",\n      \"type\": \"code\",\n      \"data\": {\n        \"code\": \"const renderTarget = new THREE.WebGLMultipleRenderTargets(512, 512, 2);\\nrenderTarget.texture[0].format = THREE.RGBAFormat; // 첫 번째 텍스처\\nrenderTarget.texture[1].format = THREE.RGBAFormat; // 두 번째 텍스처\",\n        \"language\": \"javascript\",\n        \"showlinenumbers\": true\n      }\n    },\n    {\n      \"id\": \"bFbcW5O6RF\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"(2) Custom Render Pass\",\n        \"level\": 5\n      }\n    },\n    {\n      \"id\": \"GCQNmuMOMt\",\n      \"type\": \"paragraph\",\n      \"data\": {\n        \"text\": \"포스트 프로세싱 효과를 추가하려면 Three.js의 EffectComposer와 커스텀 쉐이더를 조합합니다.\"\n      },\n      \"tunes\": {\n        \"textVariant\": \"\"\n      }\n    },\n    {\n      \"id\": \"gGMR67yiBH\",\n      \"type\": \"code\",\n      \"data\": {\n        \"code\": \"import { Pass } from 'three/examples/jsm/postprocessing/Pass.js';\\n\\nclass CustomPass extends Pass {\\n  constructor() {\\n    super();\\n    this.uniforms = { tDiffuse: { value: null } };\\n    this.material = new THREE.ShaderMaterial({\\n      uniforms: this.uniforms,\\n      vertexShader: vertexShaderCode,\\n      fragmentShader: fragmentShaderCode,\\n    });\\n  }\\n  render(renderer, writeBuffer, readBuffer) {\\n    this.uniforms.tDiffuse.value = readBuffer.texture;\\n    renderer.setRenderTarget(writeBuffer);\\n    renderer.render(this.scene, this.camera);\\n  }\\n}\",\n        \"language\": \"javascript\",\n        \"showlinenumbers\": true\n      }\n    },\n    {\n      \"id\": \"dJWPsj5AUe\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"4. 대규모 프로젝트 설계와 관리\",\n        \"level\": 4\n      }\n    },\n    {\n      \"id\": \"agcvW2ZT8w\",\n      \"type\": \"paragraph\",\n      \"data\": {\n        \"text\": \"Three.js로 대규모 애플리케이션을 개발할 때 고려해야 할 설계 및 관리 기법입니다.\"\n      },\n      \"tunes\": {\n        \"textVariant\": \"\"\n      }\n    },\n    {\n      \"id\": \"9eYrab3Yz0\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"(1) 모듈화\",\n        \"level\": 5\n      }\n    },\n    {\n      \"id\": \"krEzyFy7C2\",\n      \"type\": \"paragraph\",\n      \"data\": {\n        \"text\": \"코드를 컴포넌트 기반으로 나눠서 관리합니다. 예를 들어, 각 Mesh나 Shader를 개별 모듈로 분리합니다.\"\n      },\n      \"tunes\": {\n        \"textVariant\": \"\"\n      }\n    },\n    {\n      \"id\": \"3eqHyDWEl5\",\n      \"type\": \"code\",\n      \"data\": {\n        \"code\": \"// cube.js\\nexport function createCube() {\\n  const geometry = new THREE.BoxGeometry();\\n  const material = new THREE.MeshStandardMaterial({ color: 0x00ff00 });\\n  return new THREE.Mesh(geometry, material);\\n}\",\n        \"language\": \"plain\",\n        \"showlinenumbers\": true\n      }\n    },\n    {\n      \"id\": \"umTHOpbiUq\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"(2) 상태 관리\",\n        \"level\": 5\n      }\n    },\n    {\n      \"id\": \"-4LfWBvfRF\",\n      \"type\": \"list\",\n      \"data\": {\n        \"style\": \"unordered\",\n        \"meta\": {},\n        \"items\": [\n          {\n            \"content\": \"전역 상태를 관리하기 위해 Redux 또는 zustand 같은 상태 관리 라이브러리를 사용할 수 있습니다.\",\n            \"meta\": {},\n            \"items\": []\n          },\n          {\n            \"content\": \"각 객체의 상태는 단일 소스에서 추적하며, 변경 사항을 컴포넌트에 반영합니다.\",\n            \"meta\": {},\n            \"items\": []\n          }\n        ]\n      }\n    },\n    {\n      \"id\": \"El57taLn2f\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"(3) 테스트\",\n        \"level\": 5\n      }\n    },\n    {\n      \"id\": \"NWdDhWOI4X\",\n      \"type\": \"list\",\n      \"data\": {\n        \"style\": \"unordered\",\n        \"meta\": {},\n        \"items\": [\n          {\n            \"content\": \"렌더링이 의도한 대로 이루어졌는지 테스트하기 위해 puppeteer 같은 도구를 사용할 수 있습니다.\",\n            \"meta\": {},\n            \"items\": []\n          }\n        ]\n      }\n    },\n    {\n      \"id\": \"VVppiY5aw6\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"정리\",\n        \"level\": 3\n      }\n    },\n    {\n      \"id\": \"nUtjPiTG0D\",\n      \"type\": \"paragraph\",\n      \"data\": {\n        \"text\": \"고급 주제는 Three.js를 기본 사용에서 벗어나 성능 최적화, 셰이더 커스터마이징, WebGL의 잠재력을 끌어내는 작업을 포함합니다. 또한, 대규모 프로젝트를 설계하고 관리하는 방법론도 이 장에서 다루었습니다. 다음 장에서는 실제 사례와 다양한 애플리케이션을 소개하며 학습한 내용을 종합적으로 활용할 수 있도록 돕겠습니다.\"\n      },\n      \"tunes\": {\n        \"textVariant\": \"\"\n      }\n    }\n  ],\n  \"version\": \"2.30.7\"\n}",
  "id": "1733134153866_11"
}