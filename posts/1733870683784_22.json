{
  "title": "게임 오브젝트 제작",
  "date": 1733870683674,
  "data": "{\n  \"time\": 1734047315129,\n  \"blocks\": [\n    {\n      \"id\": \"dq-BKNJr_n\",\n      \"type\": \"paragraph\",\n      \"data\": {\n        \"text\": \"이 장에서는 외부 모델 파일을 가져오고, 애니메이션을 추가 및 제어하며, 충돌 처리 기초를 구현하는 방법을 다룹니다.게임 내 오브젝트는 시각적 표현뿐만 아니라 상호작용과 물리적 반응을 통해 게임의 재미를 높이는 중요한 요소입니다.\"\n      },\n      \"tunes\": {\n        \"textVariant\": \"\"\n      }\n    },\n    {\n      \"id\": \"-9eVqO_GgV\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"1 모델 파일 가져오기\",\n        \"level\": 3\n      }\n    },\n    {\n      \"id\": \"XFj1k-ScZW\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"1.1 GLTF/GLB 파일 로딩\",\n        \"level\": 4\n      }\n    },\n    {\n      \"id\": \"OQlfXXuE5a\",\n      \"type\": \"paragraph\",\n      \"data\": {\n        \"text\": \"GLTFLoader는 Three.js에서 가장 널리 사용되는 로더로, 외부에서 제작한 3D 모델을 로드할 수 있습니다. GLTF/GLB 형식은 텍스처, 애니메이션, 조명을 포함할 수 있어 효율적입니다.\"\n      },\n      \"tunes\": {\n        \"textVariant\": \"\"\n      }\n    },\n    {\n      \"id\": \"r5JSJO16aE\",\n      \"type\": \"list\",\n      \"data\": {\n        \"style\": \"unordered\",\n        \"meta\": {},\n        \"items\": [\n          {\n            \"content\": \"GLTF 모델 로드 코드 예제\",\n            \"meta\": {},\n            \"items\": []\n          }\n        ]\n      }\n    },\n    {\n      \"id\": \"C1cqn0d7lR\",\n      \"type\": \"code\",\n      \"data\": {\n        \"code\": \"import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';\\n\\nconst loader = new GLTFLoader();\\nloader.load(\\n    'https://hons.ghostwebservice.com/assets/animals/dog.glb', // 모델 경로\\n    (gltf) => {\\n        const model = gltf.scene; \\n        model.position.set(0, 0, 0);\\n        model.scale.set(0.5, 0.5, 0.5); // 모델 크기 조정\\n        scene.add(model);\\n    },\\n    undefined,\\n    (error) => {\\n        console.error('모델 로드 실패:', error);\\n    }\\n);\",\n        \"language\": \"javascript\",\n        \"showlinenumbers\": true\n      }\n    },\n    {\n      \"id\": \"JsZBrW-FzO\",\n      \"type\": \"embed\",\n      \"data\": {\n        \"service\": \"codepen\",\n        \"source\": \"https://codepen.io/ghostwebservice/pen/pvzEXzO\",\n        \"embed\": \"https://codepen.io/ghostwebservice/embed/pvzEXzO?height=300&theme-id=0&default-tab=css,result&embed-version=2\",\n        \"width\": 600,\n        \"height\": 300,\n        \"caption\": \"강아지 모델입니다.\"\n      }\n    },\n    {\n      \"id\": \"zhw7YZTmGJ\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"1.2 텍스처 포함 모델 확인\",\n        \"level\": 4\n      }\n    },\n    {\n      \"id\": \"d9-BhGU1f_\",\n      \"type\": \"paragraph\",\n      \"data\": {\n        \"text\": \"GLTF/GLB 파일은 텍스처와 애니메이션을 포함할 수 있습니다.\"\n      },\n      \"tunes\": {\n        \"textVariant\": \"\"\n      }\n    },\n    {\n      \"id\": \"tRRGMdwpUH\",\n      \"type\": \"list\",\n      \"data\": {\n        \"style\": \"unordered\",\n        \"meta\": {},\n        \"items\": [\n          {\n            \"content\": \"로드 후 gltf.scene의 내용을 콘솔에서 확인하여 텍스처와 애니메이션 클립이 정상적으로 포함되었는지 확인합니다.\",\n            \"meta\": {},\n            \"items\": []\n          }\n        ]\n      }\n    },\n    {\n      \"id\": \"SOQtUR80NG\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"1.3 FBX 파일 로딩\",\n        \"level\": 4\n      }\n    },\n    {\n      \"id\": \"qtjVI72Uk_\",\n      \"type\": \"paragraph\",\n      \"data\": {\n        \"text\": \"FBXLoader는 FBX 형식의 파일을 불러올 때 사용됩니다. FBX는 고해상도 애니메이션 데이터를 포함하는 데 유용합니다.\"\n      },\n      \"tunes\": {\n        \"textVariant\": \"\"\n      }\n    },\n    {\n      \"id\": \"43AsVmT2Tx\",\n      \"type\": \"list\",\n      \"data\": {\n        \"style\": \"unordered\",\n        \"meta\": {},\n        \"items\": [\n          {\n            \"content\": \"FBX 모델 로드 코드 예제\",\n            \"meta\": {},\n            \"items\": []\n          }\n        ]\n      }\n    },\n    {\n      \"id\": \"u7uBZvdIUb\",\n      \"type\": \"code\",\n      \"data\": {\n        \"code\": \"import { FBXLoader } from 'three/examples/jsm/loaders/FBXLoader.js';\\n\\nconst loader = new FBXLoader();\\nloader.load(\\n    'models/character.fbx',\\n    (fbx) => {\\n        fbx.scale.set(0.1, 0.1, 0.1);\\n        scene.add(fbx);\\n    },\\n    undefined,\\n    (error) => {\\n        console.error('FBX 로드 실패:', error);\\n    }\\n);\",\n        \"language\": \"javascript\",\n        \"showlinenumbers\": true\n      }\n    },\n    {\n      \"id\": \"YZbEp22qTK\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"2 애니메이션 추가 및 제어\",\n        \"level\": 3\n      }\n    },\n    {\n      \"id\": \"KXEgvG8gDZ\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"7.2.1 GLTF 모델에 애니메이션 추가\",\n        \"level\": 4\n      }\n    },\n    {\n      \"id\": \"1yUoeyyAe6\",\n      \"type\": \"paragraph\",\n      \"data\": {\n        \"text\": \"GLTF 파일에 포함된 애니메이션 클립을 활성화하려면 AnimationMixer를 사용합니다.\"\n      },\n      \"tunes\": {\n        \"textVariant\": \"\"\n      }\n    },\n    {\n      \"id\": \"hVf1DYCUYM\",\n      \"type\": \"list\",\n      \"data\": {\n        \"style\": \"unordered\",\n        \"meta\": {},\n        \"items\": [\n          {\n            \"content\": \"애니메이션 로드 및 실행 코드 예제\",\n            \"meta\": {},\n            \"items\": []\n          }\n        ]\n      }\n    },\n    {\n      \"id\": \"546eAFmvBT\",\n      \"type\": \"code\",\n      \"data\": {\n        \"code\": \"let mixer;\\n\\nloader.load(\\n    'models/animated_character.glb',\\n    (gltf) => {\\n        const model = gltf.scene;\\n        scene.add(model);\\n\\n        mixer = new THREE.AnimationMixer(model);\\n        const action = mixer.clipAction(gltf.animations[0]); // 첫 번째 애니메이션 실행\\n        action.play();\\n    }\\n);\\n\\nfunction animate(delta) {\\n    requestAnimationFrame(animate);\\n    if (mixer) mixer.update(delta); // 애니메이션 업데이트\\n    renderer.render(scene, camera);\\n}\\nanimate(0);\",\n        \"language\": \"javascript\",\n        \"showlinenumbers\": true\n      }\n    },\n    {\n      \"id\": \"y88m2sbfWs\",\n      \"type\": \"embed\",\n      \"data\": {\n        \"service\": \"codepen\",\n        \"source\": \"https://codepen.io/ghostwebservice/pen/wBwzLvP\",\n        \"embed\": \"https://codepen.io/ghostwebservice/embed/wBwzLvP?height=300&theme-id=0&default-tab=css,result&embed-version=2\",\n        \"width\": 600,\n        \"height\": 300,\n        \"caption\": \"모델에 내장된 애니메이션을 플레이합니다.&nbsp;\"\n      }\n    },\n    {\n      \"id\": \"6bpu7aEqRl\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"2.2 애니메이션 클립 전환\",\n        \"level\": 4\n      }\n    },\n    {\n      \"id\": \"u_0oq0FCtv\",\n      \"type\": \"paragraph\",\n      \"data\": {\n        \"text\": \"캐릭터의 동작(걷기, 달리기, 점프 등)에 따라 애니메이션 클립을 전환할 수 있습니다.\"\n      },\n      \"tunes\": {\n        \"textVariant\": \"\"\n      }\n    },\n    {\n      \"id\": \"6aBpPXwoTo\",\n      \"type\": \"list\",\n      \"data\": {\n        \"style\": \"unordered\",\n        \"meta\": {},\n        \"items\": [\n          {\n            \"content\": \"코드 예제\",\n            \"meta\": {},\n            \"items\": []\n          }\n        ]\n      }\n    },\n    {\n      \"id\": \"BN5preCBOy\",\n      \"type\": \"code\",\n      \"data\": {\n        \"code\": \"const actions = {\\n    idle: mixer.clipAction(gltf.animations[0]),\\n    walk: mixer.clipAction(gltf.animations[1]),\\n    run: mixer.clipAction(gltf.animations[2]),\\n};\\n\\n// 애니메이션 전환 함수\\nfunction switchAction(actionName) {\\n    for (const action of Object.values(actions)) {\\n        action.stop();\\n    }\\n    actions[actionName].play();\\n}\\n\\n// 예: 'walk' 애니메이션 실행\\nswitchAction('walk');\",\n        \"language\": \"javascript\",\n        \"showlinenumbers\": true\n      }\n    },\n    {\n      \"id\": \"EHVzEqg7gV\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"3 충돌 처리 기초\",\n        \"level\": 3\n      }\n    },\n    {\n      \"id\": \"NVZVuJ2iOj\",\n      \"type\": \"paragraph\",\n      \"data\": {\n        \"text\": \"충돌 처리는 게임의 상호작용 요소를 강화하는 중요한 기능입니다.Three.js 자체는 충돌 처리 기능을 제공하지 않으므로, Bounding Box를 활용하거나 Cannon.js 같은 물리 엔진을 사용할 수 있습니다.\"\n      },\n      \"tunes\": {\n        \"textVariant\": \"\"\n      }\n    },\n    {\n      \"id\": \"amsdPAWfsv\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"3.1 Bounding Box 충돌 감지\",\n        \"level\": 4\n      }\n    },\n    {\n      \"id\": \"sfV4X400Po\",\n      \"type\": \"paragraph\",\n      \"data\": {\n        \"text\": \"Box3 객체를 사용해 간단한 충돌 감지를 구현합니다.\"\n      },\n      \"tunes\": {\n        \"textVariant\": \"\"\n      }\n    },\n    {\n      \"id\": \"8i-xSDOF5G\",\n      \"type\": \"list\",\n      \"data\": {\n        \"style\": \"unordered\",\n        \"meta\": {},\n        \"items\": [\n          {\n            \"content\": \"코드 예제\",\n            \"meta\": {},\n            \"items\": []\n          }\n        ]\n      }\n    },\n    {\n      \"id\": \"szuipb-AFi\",\n      \"type\": \"code\",\n      \"data\": {\n        \"code\": \"const box1 = new THREE.Box3().setFromObject(object1); // 첫 번째 객체의 경계 상자\\nconst box2 = new THREE.Box3().setFromObject(object2); // 두 번째 객체의 경계 상자\\n\\nif (box1.intersectsBox(box2)) {\\n    console.log('충돌 발생!');\\n}\",\n        \"language\": \"javascript\",\n        \"showlinenumbers\": true\n      }\n    },\n    {\n      \"id\": \"za_p-xaxLD\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"3.2 Cannon.js를 이용한 충돌 처리\",\n        \"level\": 4\n      }\n    },\n    {\n      \"id\": \"kjwkAcuAGq\",\n      \"type\": \"paragraph\",\n      \"data\": {\n        \"text\": \"Cannon.js는 물리 기반 시뮬레이션을 위한 라이브러리입니다. 중력, 반동, 마찰을 포함한 정밀한 충돌 처리를 구현할 수 있습니다.\"\n      },\n      \"tunes\": {\n        \"textVariant\": \"\"\n      }\n    },\n    {\n      \"id\": \"kUOmQxcr-W\",\n      \"type\": \"list\",\n      \"data\": {\n        \"style\": \"unordered\",\n        \"meta\": {},\n        \"items\": [\n          {\n            \"content\": \"Cannon.js를 이용한 기본 구현\",\n            \"meta\": {},\n            \"items\": []\n          }\n        ]\n      }\n    },\n    {\n      \"id\": \"uWQWMx8yT0\",\n      \"type\": \"code\",\n      \"data\": {\n        \"code\": \"import * as CANNON from 'cannon-es';\\n\\n// Cannon.js 월드 생성\\nconst world = new CANNON.World();\\nworld.gravity.set(0, -9.82, 0);\\n\\n// 바닥 생성\\nconst groundBody = new CANNON.Body({\\n    mass: 0, // 고정된 바닥\\n    shape: new CANNON.Plane(),\\n});\\ngroundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0); // 수평 배치\\nworld.addBody(groundBody);\\n\\n// 상자 생성\\nconst boxBody = new CANNON.Body({\\n    mass: 1, // 중력 적용\\n    shape: new CANNON.Box(new CANNON.Vec3(0.5, 0.5, 0.5)),\\n});\\nboxBody.position.set(0, 5, 0); // 초기 위치\\nworld.addBody(boxBody);\\n\\n// 애니메이션 루프에서 물리 계산 업데이트\\nfunction animate() {\\n    requestAnimationFrame(animate);\\n    world.step(1 / 60); // 시간 스텝 업데이트\\n\\n    // Three.js 객체 위치 업데이트\\n    mesh.position.copy(boxBody.position);\\n    mesh.quaternion.copy(boxBody.quaternion);\\n\\n    renderer.render(scene, camera);\\n}\\nanimate();\",\n        \"language\": \"javascript\",\n        \"showlinenumbers\": true\n      }\n    },\n    {\n      \"id\": \"4Hx7jhwwaf\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"3.3 마우스 클릭으로 상호작용 추가\",\n        \"level\": 4\n      }\n    },\n    {\n      \"id\": \"Stj0mCfeMD\",\n      \"type\": \"paragraph\",\n      \"data\": {\n        \"text\": \"마우스로 오브젝트를 클릭했을 때 특정 동작(예: 점프)을 수행합니다.\"\n      },\n      \"tunes\": {\n        \"textVariant\": \"\"\n      }\n    },\n    {\n      \"id\": \"csyxkpMIHT\",\n      \"type\": \"paragraph\",\n      \"data\": {\n        \"text\": \"Cannon.js 물리 상호작용:\"\n      },\n      \"tunes\": {\n        \"textVariant\": \"\"\n      }\n    },\n    {\n      \"id\": \"v_lpKw3gEV\",\n      \"type\": \"list\",\n      \"data\": {\n        \"style\": \"unordered\",\n        \"meta\": {},\n        \"items\": [\n          {\n            \"content\": \"applyForce 메서드를 사용하여 특정 방향으로 힘을 가합니다.\",\n            \"meta\": {},\n            \"items\": []\n          }\n        ]\n      }\n    },\n    {\n      \"id\": \"kIVRpBLETf\",\n      \"type\": \"list\",\n      \"data\": {\n        \"style\": \"unordered\",\n        \"meta\": {},\n        \"items\": [\n          {\n            \"content\": \"코드 예제:\",\n            \"meta\": {},\n            \"items\": []\n          }\n        ]\n      }\n    },\n    {\n      \"id\": \"KdIai52_xL\",\n      \"type\": \"code\",\n      \"data\": {\n        \"code\": \"window.addEventListener('click', () => {\\n    boxBody.applyImpulse(new CANNON.Vec3(0, 5, 0), boxBody.position); // 위로 힘 가하기\\n});\",\n        \"language\": \"javascript\",\n        \"showlinenumbers\": true\n      }\n    },\n    {\n      \"id\": \"AIMZhXZ485\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"3.4 키보드로 상호작용 추가\",\n        \"level\": 4\n      }\n    },\n    {\n      \"id\": \"6B54r05p7J\",\n      \"type\": \"list\",\n      \"data\": {\n        \"style\": \"unordered\",\n        \"meta\": {},\n        \"items\": [\n          {\n            \"content\": \"키보드 입력 처리: \",\n            \"meta\": {},\n            \"items\": [\n              {\n                \"content\": \"keydown과 keyup 이벤트를 사용하여 keys 객체에 방향키의 상태를 기록합니다. \",\n                \"meta\": {},\n                \"items\": []\n              },\n              {\n                \"content\": \"눌린 키에 따라 상자의 움직임을 제어합니다. \",\n                \"meta\": {},\n                \"items\": []\n              }\n            ]\n          },\n          {\n            \"content\": \"Cannon.js 물리 상호작용:\",\n            \"meta\": {},\n            \"items\": [\n              {\n                \"content\": \"applyForce 메서드를 사용하여 특정 방향으로 힘을 가합니다.\",\n                \"meta\": {},\n                \"items\": []\n              },\n              {\n                \"content\": \"방향키 상태에 따라 상자가 원하는 방향으로 움직입니다.\",\n                \"meta\": {},\n                \"items\": []\n              }\n            ]\n          },\n          {\n            \"content\": \"Three.js와 Cannon.js 동기화:\",\n            \"meta\": {},\n            \"items\": [\n              {\n                \"content\": \"Cannon.js의 물리 시뮬레이션 결과를 boxMesh의 위치와 회전에 반영하여 렌더링합니다.\",\n                \"meta\": {},\n                \"items\": []\n              }\n            ]\n          }\n        ]\n      }\n    },\n    {\n      \"id\": \"AVr0kGNCrE\",\n      \"type\": \"code\",\n      \"data\": {\n        \"code\": \"import * as THREE from 'three';\\nimport * as CANNON from 'cannon-es';\\n\\n// Three.js 초기화\\nconst scene = new THREE.Scene();\\nconst camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\\nconst renderer = new THREE.WebGLRenderer();\\nrenderer.setSize(window.innerWidth, window.innerHeight);\\ndocument.body.appendChild(renderer.domElement);\\n\\n// 조명 추가\\nconst light = new THREE.DirectionalLight(0xffffff, 1);\\nlight.position.set(10, 10, 10);\\nscene.add(light);\\n\\n// Cannon.js 초기화\\nconst world = new CANNON.World();\\nworld.gravity.set(0, -9.82, 0);\\n\\n// 바닥 생성\\nconst groundBody = new CANNON.Body({\\n  mass: 0, // 고정된 바닥\\n  shape: new CANNON.Plane(),\\n});\\ngroundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0); // 수평 배치\\nworld.addBody(groundBody);\\n\\nconst groundMaterial = new THREE.MeshStandardMaterial({ color: 0x808080 });\\nconst groundMesh = new THREE.Mesh(new THREE.PlaneGeometry(20, 20), groundMaterial);\\ngroundMesh.rotation.x = -Math.PI / 2;\\nscene.add(groundMesh);\\n\\n// 상자 생성\\nconst boxBody = new CANNON.Body({\\n  mass: 1, // 중력 적용\\n  shape: new CANNON.Box(new CANNON.Vec3(0.5, 0.5, 0.5)),\\n});\\nboxBody.position.set(0, 1, 0); // 초기 위치\\nworld.addBody(boxBody);\\n\\nconst boxMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });\\nconst boxMesh = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), boxMaterial);\\nscene.add(boxMesh);\\n\\n// 카메라 위치\\ncamera.position.set(0, 5, 10);\\ncamera.lookAt(0, 0, 0);\\n\\n// 키보드 입력 상태 추적\\nconst keys = {\\n  ArrowUp: false,\\n  ArrowDown: false,\\n  ArrowLeft: false,\\n  ArrowRight: false,\\n};\\n\\n// 키보드 이벤트 핸들러\\nwindow.addEventListener('keydown', (event) => {\\n  if (keys.hasOwnProperty(event.key)) {\\n    keys[event.key] = true;\\n  }\\n});\\n\\nwindow.addEventListener('keyup', (event) => {\\n  if (keys.hasOwnProperty(event.key)) {\\n    keys[event.key] = false;\\n  }\\n});\\n\\n// 애니메이션 루프\\nfunction animate() {\\n  requestAnimationFrame(animate);\\n\\n  // 상자 이동 처리\\n  const force = 10; // 이동 속도\\n  if (keys.ArrowUp) boxBody.applyForce(new CANNON.Vec3(0, 0, -force), boxBody.position); // 앞으로\\n  if (keys.ArrowDown) boxBody.applyForce(new CANNON.Vec3(0, 0, force), boxBody.position); // 뒤로\\n  if (keys.ArrowLeft) boxBody.applyForce(new CANNON.Vec3(-force, 0, 0), boxBody.position); // 왼쪽\\n  if (keys.ArrowRight) boxBody.applyForce(new CANNON.Vec3(force, 0, 0), boxBody.position); // 오른쪽\\n\\n  // 물리 시뮬레이션 업데이트\\n  world.step(1 / 60);\\n\\n  // Three.js 메쉬 업데이트\\n  boxMesh.position.copy(boxBody.position);\\n  boxMesh.quaternion.copy(boxBody.quaternion);\\n\\n  // 렌더링\\n  renderer.render(scene, camera);\\n}\\n\\nanimate();\",\n        \"language\": \"javascript\",\n        \"showlinenumbers\": true\n      }\n    }\n  ],\n  \"version\": \"2.30.7\"\n}",
  "id": "1733870683784_22"
}