{
  "title": "효과와 연출",
  "date": 1734476516292,
  "data": "{\n  \"time\": 1734476516291,\n  \"blocks\": [\n    {\n      \"id\": \"lJQzy0mC_Z\",\n      \"type\": \"paragraph\",\n      \"data\": {\n        \"text\": \"이 문서에서는 게임의 몰입감을 높이기 위해 사용하는 시각적 효과와 카메라 연출을 구현하는 방법을 다룹니다. 주요 내용은 다음과 같습니다:\"\n      },\n      \"tunes\": {\n        \"textVariant\": \"\"\n      }\n    },\n    {\n      \"id\": \"_hM6tQz3AO\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"1 파티클 시스템을 활용한 스킬 이펙트\",\n        \"level\": 2\n      }\n    },\n    {\n      \"id\": \"INWUGQH9Qq\",\n      \"type\": \"paragraph\",\n      \"data\": {\n        \"text\": \"파티클 시스템은 폭발, 불꽃, 마법 스킬 등을 표현하는 데 효과적입니다. 이 예제에서는 Three.js를 사용하여 마법 스킬(예: 파이어볼 폭발 이펙트)을 구현합니다.\"\n      },\n      \"tunes\": {\n        \"textVariant\": \"\"\n      }\n    },\n    {\n      \"id\": \"cM75gOXAQm\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"파티클 설정 및 속성 초기화\",\n        \"level\": 4\n      }\n    },\n    {\n      \"id\": \"D0hWXPnEIM\",\n      \"type\": \"paragraph\",\n      \"data\": {\n        \"text\": \"파티클을 만들기 위해 BufferGeometry를 사용해 위치, 속도, 색상, 수명 등을 설정합니다.\"\n      },\n      \"tunes\": {\n        \"textVariant\": \"\"\n      }\n    },\n    {\n      \"id\": \"SYWlrn1O-l\",\n      \"type\": \"code\",\n      \"data\": {\n        \"code\": \"const particleCount = 500;\\nconst particlesGeometry = new THREE.BufferGeometry();\\nconst positions = [];\\nconst velocities = [];\\nconst lifetimes = []; // 수명\\nconst colors = [];\\nconst opacityArray = []; // 투명도 배열\\nconst gravity = -0.02;\\n\\nfor (let i = 0; i < particleCount; i++) {\\n  // 초기 위치 설정\\n  positions.push(0, 0, 0);\\n\\n  // 속도 설정\\n  const speed = 0.5 + Math.random();\\n  velocities.push(\\n    (Math.random() - 0.5) * speed,\\n    Math.random() * speed,\\n    (Math.random() - 0.5) * speed\\n  );\\n\\n  // 수명 설정\\n  lifetimes.push(Math.random() * 100 + 50);\\n\\n  // 초기 색상 및 투명도\\n  colors.push(1, 0.5, 0); // 주황색\\n  opacityArray.push(1.0); // 불투명\\n}\\n\\nparticlesGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));\\nparticlesGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));\",\n        \"language\": \"javascript\",\n        \"showlinenumbers\": true\n      }\n    },\n    {\n      \"id\": \"ErcLMdJxYo\",\n      \"type\": \"list\",\n      \"data\": {\n        \"style\": \"unordered\",\n        \"meta\": {},\n        \"items\": [\n          {\n            \"content\": \"파티클 개수 : particleCount만큼 파티클을 생성합니다.\",\n            \"meta\": {},\n            \"items\": []\n          },\n          {\n            \"content\": \"속성 배열:\",\n            \"meta\": {},\n            \"items\": [\n              {\n                \"content\": \"positions : 각 파티클의 (x, y, z) 좌표를 저장합니다.\",\n                \"meta\": {},\n                \"items\": []\n              },\n              {\n                \"content\": \"velocities : 각 파티클이 이동하는 속도 및 방향을 저장합니다.\",\n                \"meta\": {},\n                \"items\": []\n              },\n              {\n                \"content\": \"lifetimes : 각 파티클의 수명을 설정합니다. (50~150 프레임)\",\n                \"meta\": {},\n                \"items\": []\n              },\n              {\n                \"content\": \"colors : 초기 색상(RGB 값)을 설정합니다.\",\n                \"meta\": {},\n                \"items\": []\n              },\n              {\n                \"content\": \"opacityArray : 초기 투명도를 설정합니다.\",\n                \"meta\": {},\n                \"items\": []\n              }\n            ]\n          },\n          {\n            \"content\": \"속도 초기화 :\",\n            \"meta\": {},\n            \"items\": [\n              {\n                \"content\": \"Math.random()으로 속도를 무작위로 설정해 모든 파티클이 다른 방향으로 퍼지도록 합니다.\",\n                \"meta\": {},\n                \"items\": []\n              }\n            ]\n          }\n        ]\n      }\n    },\n    {\n      \"id\": \"ryZqfAMk_j\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \" 파티클 재질(Material) 및 텍스처 적용\",\n        \"level\": 4\n      }\n    },\n    {\n      \"id\": \"QFeWpkkQzf\",\n      \"type\": \"paragraph\",\n      \"data\": {\n        \"text\": \"파티클의 재질에 텍스처와 색상을 적용합니다.\"\n      },\n      \"tunes\": {\n        \"textVariant\": \"\"\n      }\n    },\n    {\n      \"id\": \"VxTDGJVjcj\",\n      \"type\": \"code\",\n      \"data\": {\n        \"code\": \"const textureLoader = new THREE.TextureLoader();\\nconst particleTexture = textureLoader.load('파티클.png');\\n\\nconst particleMaterial = new THREE.PointsMaterial({\\n  map: particleTexture,\\n  vertexColors: true,      // 각 파티클에 색상 적용\\n  size: 0.5,\\n  transparent: true,\\n  opacity: 1.0,\\n  depthWrite: false,\\n  blending: THREE.AdditiveBlending\\n});\\n\\nconst particleSystem = new THREE.Points(particlesGeometry, particleMaterial);\\nscene.add(particleSystem);\",\n        \"language\": \"javascript\",\n        \"showlinenumbers\": true\n      }\n    },\n    {\n      \"id\": \"yqKAOs28qZ\",\n      \"type\": \"list\",\n      \"data\": {\n        \"style\": \"unordered\",\n        \"meta\": {},\n        \"items\": [\n          {\n            \"content\": \"THREE.TextureLoader : 텍스처 이미지를 로드합니다.\",\n            \"meta\": {},\n            \"items\": []\n          },\n          {\n            \"content\": \"THREE.PointsMaterial : 파티클을 렌더링할 재질을 설정합니다.\",\n            \"meta\": {},\n            \"items\": [\n              {\n                \"content\": \"map : 파티클 텍스처를 적용합니다.\",\n                \"meta\": {},\n                \"items\": []\n              },\n              {\n                \"content\": \"vertexColors: true : 각 파티클의 색상이 반영되도록 설정합니다.\",\n                \"meta\": {},\n                \"items\": []\n              },\n              {\n                \"content\": \"size : 파티클의 크기를 설정합니다.\",\n                \"meta\": {},\n                \"items\": []\n              },\n              {\n                \"content\": \"transparent 및 opacity : 투명도 설정.\",\n                \"meta\": {},\n                \"items\": []\n              },\n              {\n                \"content\": \"depthWrite: false : 파티클이 겹칠 때 깊이 버퍼를 무시하고 투명하게 렌더링합니다.\",\n                \"meta\": {},\n                \"items\": []\n              },\n              {\n                \"content\": \"blending: THREE.AdditiveBlending : 색상을 밝게 혼합해 효과를 극대화합니다.\",\n                \"meta\": {},\n                \"items\": []\n              }\n            ]\n          }\n        ]\n      }\n    },\n    {\n      \"id\": \"Uwnu9EiGUb\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"애니메이션 루프 (파티클 이동, 색상 변화, 수명 관리)\",\n        \"level\": 4\n      }\n    },\n    {\n      \"id\": \"7BFy2qODam\",\n      \"type\": \"paragraph\",\n      \"data\": {\n        \"text\": \"파티클의 이동과 수명 변화를 주기적으로 업데이트합니다.\"\n      },\n      \"tunes\": {\n        \"textVariant\": \"\"\n      }\n    },\n    {\n      \"id\": \"mcF2h07f0o\",\n      \"type\": \"code\",\n      \"data\": {\n        \"code\": \"function animate() {\\n  requestAnimationFrame(animate);\\n\\n  const positions = particlesGeometry.attributes.position.array;\\n  const colors = particlesGeometry.attributes.color.array;\\n\\n  for (let i = 0; i < particleCount; i++) {\\n    // 속도 적용\\n    positions[i * 3] += velocities[i * 3];\\n    positions[i * 3 + 1] += velocities[i * 3 + 1];\\n    positions[i * 3 + 2] += velocities[i * 3 + 2];\\n\\n    // 중력 적용\\n    velocities[i * 3 + 1] += gravity;\\n\\n    // 수명 감소\\n    lifetimes[i]--;\\n\\n    // 색상 및 투명도 변화\\n    const lifetimeRatio = lifetimes[i] / 150;\\n    colors[i * 3] = lifetimeRatio;    // R 값 (어두워짐)\\n    colors[i * 3 + 1] = lifetimeRatio * 0.5;\\n    colors[i * 3 + 2] = 0;\\n\\n    // 수명이 끝난 파티클 초기화\\n    if (lifetimes[i] <= 0 || positions[i * 3 + 1] < -5) {\\n      positions[i * 3] = 0;\\n      positions[i * 3 + 1] = 0;\\n      positions[i * 3 + 2] = 0;\\n\\n      velocities[i * 3] = (Math.random() - 0.5) * 0.5;\\n      velocities[i * 3 + 1] = Math.random() * 0.5;\\n      velocities[i * 3 + 2] = (Math.random() - 0.5) * 0.5;\\n\\n      lifetimes[i] = Math.random() * 100 + 50;\\n    }\\n  }\\n\\n  particlesGeometry.attributes.position.needsUpdate = true;\\n  particlesGeometry.attributes.color.needsUpdate = true;\\n\\n  renderer.render(scene, camera);\\n}\\n\\nanimate();\",\n        \"language\": \"javascript\",\n        \"showlinenumbers\": true\n      }\n    },\n    {\n      \"id\": \"gXNd43cl-n\",\n      \"type\": \"list\",\n      \"data\": {\n        \"style\": \"unordered\",\n        \"meta\": {},\n        \"items\": [\n          {\n            \"content\": \"위치 업데이트 : 파티클의 속도에 따라 위치를 변경합니다.\",\n            \"meta\": {},\n            \"items\": []\n          },\n          {\n            \"content\": \"중력 적용 : velocities[i * 3 + 1] 값에 중력을 추가하여 파티클이 아래로 떨어지도록 만듭니다.\",\n            \"meta\": {},\n            \"items\": []\n          },\n          {\n            \"content\": \"수명 관리 :\",\n            \"meta\": {},\n            \"items\": [\n              {\n                \"content\": \"lifetimes[i]를 감소시키며, 수명이 끝나면 파티클을 재초기화합니다.\",\n                \"meta\": {},\n                \"items\": []\n              }\n            ]\n          },\n          {\n            \"content\": \"색상 변화 :\",\n            \"meta\": {},\n            \"items\": [\n              {\n                \"content\": \"수명 비율에 따라 색상을 점차 어둡게 변경합니다.\",\n                \"meta\": {},\n                \"items\": []\n              }\n            ]\n          },\n          {\n            \"content\": \"속성 업데이트 :\",\n            \"meta\": {},\n            \"items\": [\n              {\n                \"content\": \"needsUpdate를 true로 설정해 파티클 위치와 색상 변화를 즉시 반영합니다.\",\n                \"meta\": {},\n                \"items\": []\n              }\n            ]\n          }\n        ]\n      }\n    },\n    {\n      \"id\": \"SmeFJi8wG6\",\n      \"type\": \"embed\",\n      \"data\": {\n        \"service\": \"codepen\",\n        \"source\": \"https://codepen.io/ghostwebservice/pen/mybRyJX\",\n        \"embed\": \"https://codepen.io/ghostwebservice/embed/mybRyJX?height=300&theme-id=0&default-tab=css,result&embed-version=2\",\n        \"width\": 600,\n        \"height\": 300,\n        \"caption\": \"좀 더 수준있는 파티클은 심화 과정에서 다루겠습니다.\"\n      }\n    },\n    {\n      \"id\": \"MrZuDmPI8t\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"2 Postprocessing을 활용한 Bloom 효과\",\n        \"level\": 2\n      }\n    },\n    {\n      \"id\": \"OuvWyXps0d\",\n      \"type\": \"paragraph\",\n      \"data\": {\n        \"text\": \"Bloom 효과는 밝은 영역이 주변으로 부드럽게 퍼지는 시각 효과로, 게임의 화려함과 몰입감을 강화합니다.\"\n      },\n      \"tunes\": {\n        \"textVariant\": \"\"\n      }\n    },\n    {\n      \"id\": \"8KHYroRa-H\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"모듈 및 라이브러리\",\n        \"level\": 4\n      }\n    },\n    {\n      \"id\": \"YhM2MseLdi\",\n      \"type\": \"code\",\n      \"data\": {\n        \"code\": \"import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';\\nimport { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';\\nimport { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';\",\n        \"language\": \"javascript\",\n        \"showlinenumbers\": true\n      }\n    },\n    {\n      \"id\": \"HW1CP3Ln-l\",\n      \"type\": \"list\",\n      \"data\": {\n        \"style\": \"unordered\",\n        \"meta\": {},\n        \"items\": [\n          {\n            \"content\": \"EffectComposer: Three.js의 후처리 효과를 관리하는 클래스로, 여러 개의 **패스(효과)**를 추가하여 렌더링할 수 있습니다.\",\n            \"meta\": {},\n            \"items\": []\n          },\n          {\n            \"content\": \"RenderPass: 씬과 카메라를 기본적으로 렌더링하는 패스입니다. 이후에 추가하는 다른 패스들에 영향을 줍니다.\",\n            \"meta\": {},\n            \"items\": []\n          },\n          {\n            \"content\": \"UnrealBloomPass: 광원이나 발광 효과가 있는 객체에 블룸(Bloom) 효과를 적용합니다. 빛이 번지는 효과를 나타냅니다.\",\n            \"meta\": {},\n            \"items\": []\n          }\n        ]\n      }\n    },\n    {\n      \"id\": \"WGgozAFXWy\",\n      \"type\": \"paragraph\",\n      \"data\": {\n        \"text\": \"이 부분은 **후처리 효과(Post-Processing)**를 설정하기 위해 외부 라이브러리를 가져오는 것입니다.\"\n      },\n      \"tunes\": {\n        \"textVariant\": \"\"\n      }\n    },\n    {\n      \"id\": \"W-VDaHhaUD\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"후처리(Postprocessing) 설정\",\n        \"level\": 4\n      }\n    },\n    {\n      \"id\": \"12uSKGgatg\",\n      \"type\": \"code\",\n      \"data\": {\n        \"code\": \"const composer = new EffectComposer(renderer);\\ncomposer.addPass(new RenderPass(scene, camera));\\n\\nconst bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);\\ncomposer.addPass(bloomPass);\",\n        \"language\": \"javascript\",\n        \"showlinenumbers\": true\n      }\n    },\n    {\n      \"id\": \"PGc9gKk4je\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"EffectComposer\",\n        \"level\": 4\n      }\n    },\n    {\n      \"id\": \"xn9vqPgmZl\",\n      \"type\": \"list\",\n      \"data\": {\n        \"style\": \"unordered\",\n        \"meta\": {},\n        \"items\": [\n          {\n            \"content\": \"EffectComposer: 렌더러에 후처리 효과를 추가하고 여러 효과를 연속적으로 실행할 수 있게 합니다.\",\n            \"meta\": {},\n            \"items\": []\n          },\n          {\n            \"content\": \"composer.addPass(): 각 패스를 추가합니다.\",\n            \"meta\": {},\n            \"items\": []\n          }\n        ]\n      }\n    },\n    {\n      \"id\": \"qlIYJooi5I\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"RenderPass\",\n        \"level\": 4\n      }\n    },\n    {\n      \"id\": \"ewFUQQ5ip5\",\n      \"type\": \"list\",\n      \"data\": {\n        \"style\": \"unordered\",\n        \"meta\": {},\n        \"items\": [\n          {\n            \"content\": \"RenderPass: 씬(Scene)과 카메라(Camera)를 렌더링하는 패스입니다.이 패스는 다른 효과들이 적용되기 전에 기본적인 렌더링 결과를 만듭니다.\",\n            \"meta\": {},\n            \"items\": [\n              {\n                \"content\": \"이 패스는 다른 효과들이 적용되기 전에 기본적인 렌더링 결과를 만듭니다.\",\n                \"meta\": {},\n                \"items\": []\n              }\n            ]\n          }\n        ]\n      }\n    },\n    {\n      \"id\": \"TCUhoLgmZI\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"UnrealBloomPass\",\n        \"level\": 4\n      }\n    },\n    {\n      \"id\": \"5JshQUF7ce\",\n      \"type\": \"list\",\n      \"data\": {\n        \"style\": \"unordered\",\n        \"meta\": {},\n        \"items\": [\n          {\n            \"content\": \"UnrealBloomPass: 블룸 효과를 적용합니다.new THREE.Vector2(window.innerWidth, window.innerHeight): 화면의 해상도를 설정합니다.1.5: 블룸 효과의 강도(strength)입니다.0.4: 블룸의 반경(radius)입니다.0.85: 블룸의 threshold(임계값)입니다. 이 값 이상 밝은 부분만 블룸 효과가 적용됩니다.\",\n            \"meta\": {},\n            \"items\": []\n          }\n        ]\n      }\n    },\n    {\n      \"id\": \"Ufl6EuHJUL\",\n      \"type\": \"embed\",\n      \"data\": {\n        \"service\": \"codepen\",\n        \"source\": \"https://codepen.io/ghostwebservice/pen/gbYmYKY\",\n        \"embed\": \"https://codepen.io/ghostwebservice/embed/gbYmYKY?height=300&theme-id=0&default-tab=css,result&embed-version=2\",\n        \"width\": 600,\n        \"height\": 300,\n        \"caption\": \"구가 빛나는 효과를 줄 수 있습니다.\"\n      }\n    },\n    {\n      \"id\": \"QE93reziek\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"3 카메라 연출\",\n        \"level\": 2\n      }\n    },\n    {\n      \"id\": \"U42-qnFG2o\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"1) 카메라 Shake 효과\",\n        \"level\": 4\n      }\n    },\n    {\n      \"id\": \"6PIEFoTs7g\",\n      \"type\": \"paragraph\",\n      \"data\": {\n        \"text\": \"Shake 효과는 캐릭터가 충격을 받거나 큰 사건이 발생했을 때 카메라를 흔들어 긴장감을 전달합니다.\"\n      },\n      \"tunes\": {\n        \"textVariant\": \"\"\n      }\n    },\n    {\n      \"id\": \"gsJsOl3Tts\",\n      \"type\": \"code\",\n      \"data\": {\n        \"code\": \"function shakeCamera(intensity = 0.5, duration = 0.3) {\\n  const startTime = performance.now();\\n\\n  function updateShake() {\\n    const elapsed = performance.now() - startTime;\\n    if (elapsed > duration * 1000) return;\\n\\n    const shakeX = (Math.random() - 0.5) * intensity;\\n    const shakeY = (Math.random() - 0.5) * intensity;\\n\\n    camera.position.x += shakeX;\\n    camera.position.y += shakeY;\\n\\n    requestAnimationFrame(updateShake);\\n  }\\n\\n  updateShake();\\n}\\n\\n// 충격 발생 시 호출\\ndocument.addEventListener('keydown', (event) => {\\n  if (event.key === ' ') { // Spacebar로 트리거\\n    shakeCamera();\\n  }\\n});\",\n        \"language\": \"javascript\",\n        \"showlinenumbers\": true\n      }\n    },\n    {\n      \"id\": \"AhTDyaYZQi\",\n      \"type\": \"embed\",\n      \"data\": {\n        \"service\": \"codepen\",\n        \"source\": \"https://codepen.io/ghostwebservice/pen/JoPEoeO\",\n        \"embed\": \"https://codepen.io/ghostwebservice/embed/JoPEoeO?height=300&theme-id=0&default-tab=css,result&embed-version=2\",\n        \"width\": 600,\n        \"height\": 300,\n        \"caption\": \"스페이스바를 누르면 카메라가 흔들립니다.\"\n      }\n    },\n    {\n      \"id\": \"Fccc8QZwIE\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"2) 카메라 Zoom 효과\",\n        \"level\": 4\n      }\n    },\n    {\n      \"id\": \"PEWt97omnC\",\n      \"type\": \"paragraph\",\n      \"data\": {\n        \"text\": \"Zoom 효과는 특정 상황에서 집중감을 높이는 데 유용합니다.\"\n      },\n      \"tunes\": {\n        \"textVariant\": \"\"\n      }\n    },\n    {\n      \"id\": \"0PwMDbm6C4\",\n      \"type\": \"code\",\n      \"data\": {\n        \"code\": \"function zoomCamera(targetFov, duration = 1) {\\n  const startFov = camera.fov;\\n  const deltaFov = targetFov - startFov;\\n  const startTime = performance.now();\\n\\n  function updateZoom() {\\n    const elapsed = performance.now() - startTime;\\n    if (elapsed > duration * 1000) {\\n      camera.fov = targetFov;\\n      camera.updateProjectionMatrix();\\n      return;\\n    }\\n\\n    const progress = elapsed / (duration * 1000);\\n    camera.fov = startFov + deltaFov * progress;\\n    camera.updateProjectionMatrix();\\n\\n    requestAnimationFrame(updateZoom);\\n  }\\n\\n  updateZoom();\\n}\\n\\n// 줌 트리거\\ndocument.addEventListener('keydown', (event) => {\\n  if (event.key === 'z') { // Z 키로 줌\\n    zoomCamera(30); // FOV를 30으로 축소\\n  } else if (event.key === 'x') { // X 키로 원래대로\\n    zoomCamera(75); // FOV를 기본값으로 복원\\n  }\\n});\",\n        \"language\": \"javascript\",\n        \"showlinenumbers\": true\n      }\n    },\n    {\n      \"id\": \"zZVMZtXK2O\",\n      \"type\": \"paragraph\",\n      \"data\": {\n        \"text\": \"집중된 시각 연출: 특정 이벤트에서 카메라를 줌 인/아웃하여 게임플레이에 집중감을 줍니다.\"\n      },\n      \"tunes\": {\n        \"textVariant\": \"\"\n      }\n    }\n  ],\n  \"version\": \"2.30.7\"\n}",
  "id": "1734476516020_31"
}