{
  "title": " 인터랙티브 요소 추가",
  "date": 1733544986898,
  "data": "{\n  \"time\": 1733704898666,\n  \"blocks\": [\n    {\n      \"id\": \"pYgj7p0Wju\",\n      \"type\": \"paragraph\",\n      \"data\": {\n        \"text\": \"이 장에서는 사용자와의 상호작용을 통해 Three.js 장면을 더 생동감 있게 만드는 방법을 다룹니다. 인터랙션을 통해 사용자가 객체를 클릭하거나, 드래그하거나, 화면 내 동적인 변화를 경험하도록 구현합니다.\"\n      },\n      \"tunes\": {\n        \"textVariant\": \"\"\n      }\n    },\n    {\n      \"id\": \"CIqir4dBWr\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"1 사용자 입력의 이해\",\n        \"level\": 4\n      }\n    },\n    {\n      \"id\": \"OtqusoUDXQ\",\n      \"type\": \"paragraph\",\n      \"data\": {\n        \"text\": \"Three.js에서 마우스, 키보드, 터치 입력을 처리하는 기법을 소개합니다.\"\n      },\n      \"tunes\": {\n        \"textVariant\": \"\"\n      }\n    },\n    {\n      \"id\": \"LpQQGbgCrQ\",\n      \"type\": \"paragraph\",\n      \"data\": {\n        \"text\": \"입력 이벤트\"\n      },\n      \"tunes\": {\n        \"textVariant\": \"\"\n      }\n    },\n    {\n      \"id\": \"vxLGcVT3Gn\",\n      \"type\": \"list\",\n      \"data\": {\n        \"style\": \"unordered\",\n        \"meta\": {},\n        \"items\": [\n          {\n            \"content\": \"mousemove: 마우스 이동 이벤트\",\n            \"meta\": {},\n            \"items\": []\n          },\n          {\n            \"content\": \"click: 클릭 이벤트\",\n            \"meta\": {},\n            \"items\": []\n          },\n          {\n            \"content\": \"keydown/keyup: 키보드 이벤트\",\n            \"meta\": {},\n            \"items\": []\n          },\n          {\n            \"content\": \"touchstart/touchmove/touchend: 터치 이벤트\",\n            \"meta\": {},\n            \"items\": []\n          }\n        ]\n      }\n    },\n    {\n      \"id\": \"dB5fktRFiT\",\n      \"type\": \"paragraph\",\n      \"data\": {\n        \"text\": \"RaycasterThree.js에서 마우스 입력으로 3D 객체를 선택하기 위해 Raycaster를 사용합니다.\"\n      },\n      \"tunes\": {\n        \"textVariant\": \"\"\n      }\n    },\n    {\n      \"id\": \"n59DH1Z_W0\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"2 객체 선택 및 상호작용\",\n        \"level\": 4\n      }\n    },\n    {\n      \"id\": \"utGgCwPyhw\",\n      \"type\": \"paragraph\",\n      \"data\": {\n        \"text\": \"1. Raycaster 초기화\"\n      },\n      \"tunes\": {\n        \"textVariant\": \"\"\n      }\n    },\n    {\n      \"id\": \"knkkY9kXn3\",\n      \"type\": \"paragraph\",\n      \"data\": {\n        \"text\": \"Raycaster를 생성하고 마우스 포인터 정보를 추적합니다.\"\n      },\n      \"tunes\": {\n        \"textVariant\": \"\"\n      }\n    },\n    {\n      \"id\": \"3NUpRh6pFS\",\n      \"type\": \"code\",\n      \"data\": {\n        \"code\": \"const raycaster = new THREE.Raycaster();\\nconst mouse = new THREE.Vector2();\\n\\n// 마우스 위치 업데이트\\nwindow.addEventListener('mousemove', (event) => {\\n    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\\n    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;\\n});\",\n        \"language\": \"javascript\",\n        \"showlinenumbers\": true\n      }\n    },\n    {\n      \"id\": \"G_k6k9BYvz\",\n      \"type\": \"paragraph\",\n      \"data\": {\n        \"text\": \"2. 객체 선택 처리\"\n      },\n      \"tunes\": {\n        \"textVariant\": \"\"\n      }\n    },\n    {\n      \"id\": \"zCBG-WH2Bm\",\n      \"type\": \"code\",\n      \"data\": {\n        \"code\": \"window.addEventListener('click', () => {\\n    raycaster.setFromCamera(mouse, camera);\\n    const intersects = raycaster.intersectObjects(scene.children);\\n\\n    if (intersects.length > 0) {\\n        const object = intersects[0].object;\\n        console.log(`Clicked on: ${object.name}`);\\n        // 예: 색상 변경\\n        object.material.color.set(0xff0000);\\n    }\\n});\",\n        \"language\": \"js\",\n        \"showlinenumbers\": true\n      }\n    },\n    {\n      \"id\": \"kbYlN6rj-V\",\n      \"type\": \"embed\",\n      \"data\": {\n        \"service\": \"codepen\",\n        \"source\": \"https://codepen.io/ghostwebservice/pen/gbYrMjy\",\n        \"embed\": \"https://codepen.io/ghostwebservice/embed/gbYrMjy?height=300&theme-id=0&default-tab=css,result&embed-version=2\",\n        \"width\": 600,\n        \"height\": 300,\n        \"caption\": \"상자를 클릭하면 색이 변경됩니다.\"\n      }\n    },\n    {\n      \"id\": \"5v9fPMrrpl\",\n      \"type\": \"paragraph\",\n      \"data\": {\n        \"text\": \"3. 객체에 이름 부여\"\n      },\n      \"tunes\": {\n        \"textVariant\": \"\"\n      }\n    },\n    {\n      \"id\": \"web2vwKu2O\",\n      \"type\": \"paragraph\",\n      \"data\": {\n        \"text\": \"각 객체에 고유한 이름을 설정하여 구분합니다.\"\n      },\n      \"tunes\": {\n        \"textVariant\": \"\"\n      }\n    },\n    {\n      \"id\": \"yvOaiB6Ygb\",\n      \"type\": \"code\",\n      \"data\": {\n        \"code\": \"const box = new THREE.Mesh(\\n    new THREE.BoxGeometry(1, 1, 1),\\n    new THREE.MeshStandardMaterial({ color: 0x00ff00 })\\n);\\nbox.name = \\\"Green Box\\\";\\nscene.add(box);\",\n        \"language\": \"javascript\",\n        \"showlinenumbers\": true\n      }\n    },\n    {\n      \"id\": \"nEBr7vYGjE\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"3 객체 드래그 앤 드롭\",\n        \"level\": 4\n      }\n    },\n    {\n      \"id\": \"xzOeZ9Gsst\",\n      \"type\": \"paragraph\",\n      \"data\": {\n        \"text\": \"1. 드래그 상태 추적드래그 시작, 진행, 종료를 추적합니다.\"\n      },\n      \"tunes\": {\n        \"textVariant\": \"\"\n      }\n    },\n    {\n      \"id\": \"fDmt3rJI5n\",\n      \"type\": \"code\",\n      \"data\": {\n        \"code\": \"let dragging = false;\\nlet selectedObject = null;\\n\\nwindow.addEventListener('mousedown', () => {\\n    raycaster.setFromCamera(mouse, camera);\\n    const intersects = raycaster.intersectObjects(scene.children);\\n    if (intersects.length > 0) {\\n        selectedObject = intersects[0].object;\\n        dragging = true;\\n    }\\n});\\n\\nwindow.addEventListener('mouseup', () => {\\n    dragging = false;\\n    selectedObject = null;\\n});\\n\\nwindow.addEventListener('mousemove', () => {\\n    if (dragging && selectedObject) {\\n        const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);\\n        const point = new THREE.Vector3();\\n        raycaster.ray.intersectPlane(plane, point);\\n        selectedObject.position.copy(point);\\n    }\\n});\",\n        \"language\": \"javascript\",\n        \"showlinenumbers\": true\n      }\n    },\n    {\n      \"id\": \"0wSczYVobG\",\n      \"type\": \"embed\",\n      \"data\": {\n        \"service\": \"codepen\",\n        \"source\": \"https://codepen.io/ghostwebservice/pen/azoNZaE\",\n        \"embed\": \"https://codepen.io/ghostwebservice/embed/azoNZaE?height=300&theme-id=0&default-tab=css,result&embed-version=2\",\n        \"width\": 600,\n        \"height\": 300,\n        \"caption\": \"마우스를 누른채 이동하면 따라옵니다.\"\n      }\n    },\n    {\n      \"id\": \"6RuacsnGEv\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"주요 코드 설명\",\n        \"level\": 5\n      }\n    },\n    {\n      \"id\": \"k8WywafpDc\",\n      \"type\": \"list\",\n      \"data\": {\n        \"style\": \"unordered\",\n        \"meta\": {},\n        \"items\": [\n          {\n            \"content\": \"Raycaster로 객체 탐지\",\n            \"meta\": {},\n            \"items\": [\n              {\n                \"content\": \"사용자가 클릭한 객체를 Raycaster를 통해 탐지하고 해당 객체를 드래그할 수 있도록 상태를 업데이트합니다.\",\n                \"meta\": {},\n                \"items\": []\n              }\n            ]\n          },\n          {\n            \"content\": \"드래그 평면 설정\",\n            \"meta\": {},\n            \"items\": [\n              {\n                \"content\": \"THREE.Plane를 사용하여 객체가 이동할 기준 평면을 설정합니다. 이 평면은 객체의 현재 위치를 기준으로 카메라와 평행하게 배치됩니다.\",\n                \"meta\": {},\n                \"items\": []\n              }\n            ]\n          },\n          {\n            \"content\": \"교차점 계산\",\n            \"meta\": {},\n            \"items\": [\n              {\n                \"content\": \"마우스 이동 시 Raycaster를 사용하여 마우스와 평면의 교차점을 계산하고 객체를 그 위치로 이동시킵니다.\",\n                \"meta\": {},\n                \"items\": []\n              }\n            ]\n          },\n          {\n            \"content\": \"드래그 상태 관리\",\n            \"meta\": {},\n            \"items\": [\n              {\n                \"content\": \"mousedown으로 드래그 시작, mouseup으로 드래그 종료를 관리하며, 객체가 아닌 곳을 클릭했을 경우 드래그 동작을 멈춥니다.\",\n                \"meta\": {},\n                \"items\": []\n              }\n            ]\n          }\n        ]\n      }\n    },\n    {\n      \"id\": \"txghN0tzUt\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"왜 plane이 필요할까?\",\n        \"level\": 4\n      }\n    },\n    {\n      \"id\": \"l5rRXv73lu\",\n      \"type\": \"paragraph\",\n      \"data\": {\n        \"text\": \"3D 공간에서 마우스는 2D 화면 좌표를 기반으로 움직입니다.하지만 객체를 3D 공간에서 이동시키려면 마우스의 움직임을 특정 3D 공간의 좌표로 변환해야 합니다.이를 위해 가상의 평면을 생성하고, 마우스와 평면의 교차점을 계산하여 객체의 새 위치를 얻습니다.\"\n      },\n      \"tunes\": {\n        \"textVariant\": \"\"\n      }\n    },\n    {\n      \"id\": \"JmY-qbhyCN\",\n      \"type\": \"paragraph\",\n      \"data\": {\n        \"text\": \"THREE.Plane은 수학적인 개념으로 사용되는 가상의 평면이며, Three.js에서 장면(Scene)에 포함되지 않습니다. 이는 3D 공간에서 특정 방향과 위치를 정의하는 수학적 평면(mathematical plane)으로, 물리적인 객체로 렌더링되지 않습니다.\"\n      },\n      \"tunes\": {\n        \"textVariant\": \"\"\n      }\n    },\n    {\n      \"id\": \"sBcDwysPWs\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"Plane의 주요 역할\",\n        \"level\": 5\n      }\n    },\n    {\n      \"id\": \"Fl2oyefEHf\",\n      \"type\": \"paragraph\",\n      \"data\": {\n        \"text\": \"이 코드에서 plane은 객체를 드래그할 때 마우스 위치를 계산하는 기준면으로 사용됩니다.\"\n      },\n      \"tunes\": {\n        \"textVariant\": \"\"\n      }\n    },\n    {\n      \"id\": \"mLZaIrQwcw\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"주요 특징\",\n        \"level\": 5\n      }\n    },\n    {\n      \"id\": \"LQTMYNhGae\",\n      \"type\": \"list\",\n      \"data\": {\n        \"style\": \"unordered\",\n        \"meta\": {},\n        \"items\": [\n          {\n            \"content\": \"렌더링되지 않음\",\n            \"meta\": {},\n            \"items\": [\n              {\n                \"content\": \"THREE.Plane은 장면에 추가되지 않으므로 화면에 보이지 않습니다. 단지 Raycaster와의 교차 계산에만 사용됩니다.\",\n                \"meta\": {},\n                \"items\": []\n              }\n            ]\n          },\n          {\n            \"content\": \"가상의 계산용 평면\",\n            \"meta\": {},\n            \"items\": [\n              {\n                \"content\": \"plane은 setFromNormalAndCoplanarPoint 메서드를 통해 특정 방향(normal)과 점(position)을 기준으로 정의됩니다.\",\n                \"meta\": {},\n                \"items\": []\n              },\n              {\n                \"content\": \"Raycaster로부터 나오는 가상의 광선(ray)과 이 평면의 교차점을 계산해 객체의 새 위치를 결정합니다.\",\n                \"meta\": {},\n                \"items\": []\n              }\n            ]\n          }\n        ]\n      }\n    },\n    {\n      \"id\": \"OOUUjwP4bd\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"코드에서의 역할\",\n        \"level\": 5\n      }\n    },\n    {\n      \"id\": \"CcRIYql37f\",\n      \"type\": \"code\",\n      \"data\": {\n        \"code\": \"plane.setFromNormalAndCoplanarPoint(\\n    camera.getWorldDirection(plane.normal), \\n    selectedObject.position\\n);\",\n        \"language\": \"javascript\",\n        \"showlinenumbers\": true\n      }\n    },\n    {\n      \"id\": \"PXgiR_QuoG\",\n      \"type\": \"paragraph\",\n      \"data\": {\n        \"text\": \"위 코드는 다음을 수행합니다:\"\n      },\n      \"tunes\": {\n        \"textVariant\": \"\"\n      }\n    },\n    {\n      \"id\": \"9NbTvBfaN2\",\n      \"type\": \"list\",\n      \"data\": {\n        \"style\": \"unordered\",\n        \"meta\": {},\n        \"items\": [\n          {\n            \"content\": \"평면의 방향 설정camera.getWorldDirection(plane.normal)을 사용하여 평면의 방향(법선 벡터)을 카메라가 바라보는 방향으로 설정합니다.이렇게 하면 드래그하는 동안 평면이 카메라와 평행하게 유지됩니다.\",\n            \"meta\": {},\n            \"items\": []\n          },\n          {\n            \"content\": \"평면 위치 설정평면이 객체의 현재 위치(selectedObject.position)를 포함하도록 설정합니다.따라서 객체를 드래그할 때 마우스 위치를 기준으로 이 평면 위에서 이동하게 됩니다.\",\n            \"meta\": {},\n            \"items\": []\n          }\n        ]\n      }\n    },\n    {\n      \"id\": \"Qz9RIZOOh2\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"4 UI와 상호작용\",\n        \"level\": 4\n      }\n    },\n    {\n      \"id\": \"RXLkujcg40\",\n      \"type\": \"paragraph\",\n      \"data\": {\n        \"text\": \"1. Dat.GUI로 파라미터 조정\"\n      },\n      \"tunes\": {\n        \"textVariant\": \"\"\n      }\n    },\n    {\n      \"id\": \"1bctMasJrR\",\n      \"type\": \"paragraph\",\n      \"data\": {\n        \"text\": \"Dat.GUI를 사용하여 실시간으로 객체 속성을 조정합니다.\"\n      },\n      \"tunes\": {\n        \"textVariant\": \"\"\n      }\n    },\n    {\n      \"id\": \"ZpFH5DIG08\",\n      \"type\": \"code\",\n      \"data\": {\n        \"code\": \"import * as dat from 'dat.gui';\\n\\nconst gui = new dat.GUI();\\nconst params = {\\n    rotationSpeed: 0.01,\\n    color: 0x00ff00\\n};\\n\\n// 사용자 입력으로 색상 및 속도 변경\\ngui.add(params, 'rotationSpeed', 0, 0.1);\\ngui.addColor(params, 'color').onChange((value) => {\\n    box.material.color.set(value);\\n});\",\n        \"language\": \"javascript\",\n        \"showlinenumbers\": true\n      }\n    },\n    {\n      \"id\": \"_KXNFVq6UP\",\n      \"type\": \"paragraph\",\n      \"data\": {\n        \"text\": \"2. HTML 버튼과 Three.js 상호작용\"\n      },\n      \"tunes\": {\n        \"textVariant\": \"\"\n      }\n    },\n    {\n      \"id\": \"xPxnZJEBL2\",\n      \"type\": \"paragraph\",\n      \"data\": {\n        \"text\": \"HTML 버튼으로 객체를 제어합니다.\"\n      },\n      \"tunes\": {\n        \"textVariant\": \"\"\n      }\n    },\n    {\n      \"id\": \"LSabYdrpdM\",\n      \"type\": \"code\",\n      \"data\": {\n        \"code\": \"<button id=\\\"rotate\\\">Rotate Object</button>\\n\",\n        \"language\": \"javascript\",\n        \"showlinenumbers\": true\n      }\n    },\n    {\n      \"id\": \"wtSjJcTLIT\",\n      \"type\": \"code\",\n      \"data\": {\n        \"code\": \"document.getElementById('rotate').addEventListener('click', () => {\\n    box.rotation.y += Math.PI / 4;\\n});\",\n        \"language\": \"javascript\",\n        \"showlinenumbers\": true\n      }\n    },\n    {\n      \"id\": \"vrgpGjDejW\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"5 물리 기반 상호작용\",\n        \"level\": 4\n      }\n    },\n    {\n      \"id\": \"brHm0nLn-5\",\n      \"type\": \"paragraph\",\n      \"data\": {\n        \"text\": \"1. 물리 엔진 통합\"\n      },\n      \"tunes\": {\n        \"textVariant\": \"\"\n      }\n    },\n    {\n      \"id\": \"pU7D8WgJ6i\",\n      \"type\": \"paragraph\",\n      \"data\": {\n        \"text\": \"cannon-es 또는 ammo.js를 사용하여 물리 기반 상호작용을 추가합니다.\"\n      },\n      \"tunes\": {\n        \"textVariant\": \"\"\n      }\n    },\n    {\n      \"id\": \"N-BT4qShGT\",\n      \"type\": \"code\",\n      \"data\": {\n        \"code\": \"import * as CANNON from 'cannon-es';\\n\\n// 물리 세계 생성\\nconst world = new CANNON.World();\\nworld.gravity.set(0, -9.8, 0);\\n\\n// 물리 객체 생성\\nconst shape = new CANNON.Box(new CANNON.Vec3(0.5, 0.5, 0.5));\\nconst body = new CANNON.Body({ mass: 1 });\\nbody.addShape(shape);\\nbody.position.set(0, 5, 0);\\nworld.addBody(body);\",\n        \"language\": \"javascript\",\n        \"showlinenumbers\": true\n      }\n    },\n    {\n      \"id\": \"zR3KBRIahN\",\n      \"type\": \"paragraph\",\n      \"data\": {\n        \"text\": \"2. Three.js와 동기화\"\n      },\n      \"tunes\": {\n        \"textVariant\": \"\"\n      }\n    },\n    {\n      \"id\": \"QySViLHRs6\",\n      \"type\": \"paragraph\",\n      \"data\": {\n        \"text\": \"Three.js의 객체 위치를 물리 시뮬레이션 결과와 동기화합니다.\"\n      },\n      \"tunes\": {\n        \"textVariant\": \"\"\n      }\n    },\n    {\n      \"id\": \"vcwT0GXclK\",\n      \"type\": \"code\",\n      \"data\": {\n        \"code\": \"function animatePhysics(deltaTime) {\\n    world.step(deltaTime);\\n\\n    // 물리 객체 위치 업데이트\\n    box.position.copy(body.position);\\n    box.quaternion.copy(body.quaternion);\\n}\\n\\nfunction animate() {\\n    const deltaTime = clock.getDelta();\\n    animatePhysics(deltaTime);\\n    renderer.render(scene, camera);\\n    requestAnimationFrame(animate);\\n}\\n\\nanimate();\",\n        \"language\": \"javascript\",\n        \"showlinenumbers\": true\n      }\n    },\n    {\n      \"id\": \"Oenl4eB9By\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"6 카메라와의 상호작용\",\n        \"level\": 4\n      }\n    },\n    {\n      \"id\": \"INGyjy5HO9\",\n      \"type\": \"paragraph\",\n      \"data\": {\n        \"text\": \"1. OrbitControls\"\n      },\n      \"tunes\": {\n        \"textVariant\": \"\"\n      }\n    },\n    {\n      \"id\": \"ZRf3ebSA2p\",\n      \"type\": \"paragraph\",\n      \"data\": {\n        \"text\": \"사용자가 카메라를 드래그하여 장면을 둘러볼 수 있도록 설정합니다.\"\n      },\n      \"tunes\": {\n        \"textVariant\": \"\"\n      }\n    },\n    {\n      \"id\": \"QlM91kM30o\",\n      \"type\": \"code\",\n      \"data\": {\n        \"code\": \"import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';\\n\\nconst controls = new OrbitControls(camera, renderer.domElement);\\ncontrols.enableDamping = true;\\ncontrols.dampingFactor = 0.1;\",\n        \"language\": \"javascript\",\n        \"showlinenumbers\": true\n      }\n    },\n    {\n      \"id\": \"n1vK-CBol4\",\n      \"type\": \"paragraph\",\n      \"data\": {\n        \"text\": \"2. 카메라 이동 제어\"\n      },\n      \"tunes\": {\n        \"textVariant\": \"\"\n      }\n    },\n    {\n      \"id\": \"L67w9HIkEL\",\n      \"type\": \"paragraph\",\n      \"data\": {\n        \"text\": \"화살표 키를 사용하여 카메라를 이동시킵니다.\"\n      },\n      \"tunes\": {\n        \"textVariant\": \"\"\n      }\n    },\n    {\n      \"id\": \"i1koNHM7r0\",\n      \"type\": \"code\",\n      \"data\": {\n        \"code\": \"document.addEventListener('keydown', (event) => {\\n    const speed = 0.5;\\n    if (event.code === 'ArrowUp') camera.position.z -= speed;\\n    if (event.code === 'ArrowDown') camera.position.z += speed;\\n    if (event.code === 'ArrowLeft') camera.position.x -= speed;\\n    if (event.code === 'ArrowRight') camera.position.x += speed;\\n});\",\n        \"language\": \"javascript\",\n        \"showlinenumbers\": true\n      }\n    },\n    {\n      \"id\": \"w89Tbo6lWh\",\n      \"type\": \"header\",\n      \"data\": {\n        \"text\": \"7 개선 및 확장\",\n        \"level\": 4\n      }\n    },\n    {\n      \"id\": \"gdc9ROy-zC\",\n      \"type\": \"list\",\n      \"data\": {\n        \"style\": \"unordered\",\n        \"meta\": {},\n        \"items\": [\n          {\n            \"content\": \"사용자 이벤트에 애니메이션 추가: 클릭 시 객체가 회전하거나 색상이 변하도록 설정\",\n            \"meta\": {},\n            \"items\": []\n          },\n          {\n            \"content\": \"멀티 터치 제스처: 모바일 장치에서 줌, 팬, 회전을 지원\",\n            \"meta\": {},\n            \"items\": []\n          },\n          {\n            \"content\": \"VR 컨트롤러 통합: WebXR을 활용한 VR 환경 지원\",\n            \"meta\": {},\n            \"items\": []\n          }\n        ]\n      }\n    }\n  ],\n  \"version\": \"2.30.7\"\n}",
  "id": "1733544986874_20"
}